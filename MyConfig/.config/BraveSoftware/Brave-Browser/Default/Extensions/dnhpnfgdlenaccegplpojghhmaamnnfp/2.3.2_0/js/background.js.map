{"version":3,"file":"js/background.js","mappings":"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","sources":["webpack:///./src/js/Core/Storage/Storage.js","webpack:///./src/js/Core/Info.js","webpack:///./src/js/Core/Storage/SyncedStorage.js","webpack:///./src/js/setup.js","webpack:///./src/js/Core/Errors/Errors.js","webpack:///./src/js/Core/Storage/CookieStorage.js","webpack:///./src/js/Core/Environment.js","webpack:///./src/js/Core/Localization/Language.js","webpack:///./src/js/Core/ExtensionResources.js","webpack:///./src/js/Core/Localization/Localization.js","webpack:///./src/js/Core/BackgroundSimple.js","webpack:///./src/js/Core/Storage/LocalStorage.js","webpack:///./src/js/Core/Permissions.js","webpack:///./src/js/Background/Modules/ContextMenu.js","webpack:///./src/js/Core/Utils/TimeUtils.js","webpack:///./node_modules/idb/build/wrap-idb-value.js","webpack:///./node_modules/idb/build/index.js","webpack:///./src/js/Background/Modules/IndexedDB.js","webpack:///./src/js/Core/GameId.js","webpack:///./src/js/Core/Html/Html.js","webpack:///./src/js/Core/Html/HtmlParser.js","webpack:///./src/js/Background/Modules/Api.js","webpack:///./src/js/Background/Modules/CacheStorage.js","webpack:///./src/js/Background/Modules/SteamCommunityApi.js","webpack:///./src/js/Background/Modules/SteamStoreApi.js","webpack:///./src/js/Background/Modules/StaticResources.js","webpack:///./src/js/config.js","webpack:///./src/js/Background/Modules/ITADApi.js","webpack:///./src/js/Background/Modules/AugmentedSteamApi.js","webpack:///./src/js/Background/Modules/ExtensionData.js","webpack:///./src/js/Background/background.js"],"sourcesContent":["class Storage {\r\n\r\n    static has(key) {\r\n        return Object.prototype.hasOwnProperty.call(this.cache, key);\r\n    }\r\n\r\n    static get(key) {\r\n        if (typeof this.cache[key] !== \"undefined\" || typeof this.defaults === \"undefined\") {\r\n            return this.cache[key];\r\n        }\r\n        if (typeof this.defaults[key] === \"undefined\") {\r\n            console.warn('Unrecognized storage key \"%s\"', key);\r\n        }\r\n        return this.defaults[key];\r\n    }\r\n\r\n    static set(key, value) {\r\n        this.cache[key] = value;\r\n        return this._adapter.set({[key]: value});\r\n    }\r\n\r\n    static import(entries) {\r\n        for (const [key, value] of Object.entries(entries)) {\r\n            this.cache[key] = value;\r\n        }\r\n        return this._adapter.set(entries);\r\n    }\r\n\r\n    static remove(key) {\r\n        if (typeof this.cache[key] !== \"undefined\") {\r\n            delete this.cache[key];\r\n        }\r\n        return this._adapter.remove(key);\r\n    }\r\n\r\n    static keys(prefix = \"\") {\r\n        return Object.keys(this.cache).filter(k => k.startsWith(prefix));\r\n    }\r\n\r\n    static entries() {\r\n        return Object.entries(this.cache);\r\n    }\r\n\r\n    static async clear(force = false) {\r\n\r\n        let tmp;\r\n        if (!force) {\r\n            tmp = (this.persistent ?? []).reduce((acc, option) => {\r\n                acc[option] = this.cache[option];\r\n                return acc;\r\n            }, {});\r\n        }\r\n\r\n        await this._adapter.clear();\r\n        this.cache = {};\r\n\r\n        if (!force) {\r\n            await this.import(tmp);\r\n        }\r\n    }\r\n\r\n    // load whole storage and make local copy\r\n    static async init() {\r\n\r\n        const area = this._adapter === browser.storage.sync ? \"sync\" : \"local\";\r\n        const cache = Storage.caches[area];\r\n\r\n        if (typeof cache !== \"undefined\") {\r\n            this.cache = cache;\r\n            return this.cache;\r\n        }\r\n\r\n        Storage.caches[area] = {};\r\n        this.cache = Storage.caches[area];\r\n\r\n        browser.storage.onChanged.addListener((changes, eventArea) => {\r\n\r\n            if (area !== eventArea) { return; }\r\n\r\n            for (const [key, {\"newValue\": val}] of Object.entries(changes)) {\r\n                this.cache[key] = val;\r\n            }\r\n        });\r\n\r\n        return Object.assign(this.cache, await this._adapter.get(null));\r\n    }\r\n\r\n    static then(onDone, onCatch) {\r\n        const promise = this._initialized ? Promise.resolve(this.cache) : this.init();\r\n        this._initialized = true;\r\n        return promise.then(onDone, onCatch);\r\n    }\r\n\r\n    static toJson() {\r\n        return JSON.stringify(this.cache);\r\n    }\r\n}\r\n\r\nStorage.caches = {};\r\n\r\nexport {Storage};\r\n","\r\nconst Info = {\r\n    \"version\": browser.runtime.getManifest().version,\r\n    \"db_version\": 3,\r\n};\r\n\r\nexport {Info};\r\n","import {Storage} from \"./Storage\";\r\nimport {Info} from \"../Info\";\r\n\r\n/*\r\n * browser.storage.sync limits\r\n * QUOTA_BYTES = 102400 // 100KB\r\n * QUOTA_BYTES_PER_ITEM = 8192 // 8KB\r\n * MAX_ITEMS = 512\r\n * MAX_WRITE_OPERATIONS_PER_HOUR = 1800\r\n * MAX_WRITE_OPERATIONS_PER_MINUTE = 120\r\n */\r\nclass SyncedStorage extends Storage {}\r\n\r\nSyncedStorage._adapter = browser.storage.sync || browser.storage.local;\r\n\r\n/*\r\n * 8KiB is the limit for storage.sync https://chromium.googlesource.com/chromium/src/+/refs/heads/main/extensions/common/api/storage.json#227\r\n * 5MiB is the limit for storage.local (overall size) https://chromium.googlesource.com/chromium/src/+/refs/heads/main/extensions/common/api/storage.json#227\r\n * 2KiB are subtracted in order to save some space for other configuration options\r\n */\r\nSyncedStorage.QUOTA_BYTES_PER_ITEM = browser.storage.sync ? 8192 : 5242880 - 2048;\r\n\r\nSyncedStorage.defaults = Object.freeze({\r\n    \"language\": \"english\",\r\n\r\n    \"version\": Info.version,\r\n    \"version_show\": true,\r\n\r\n    \"highlight_owned_color\": \"#00ce67\",\r\n    \"highlight_wishlist_color\": \"#0491bf\",\r\n    \"highlight_coupon_color\": \"#a26426\",\r\n    \"highlight_inv_gift_color\": \"#800040\",\r\n    \"highlight_inv_guestpass_color\": \"#513c73\",\r\n    \"highlight_notinterested_color\": \"#4f4f4f\",\r\n    \"highlight_collection_color\": \"#856d0e\",\r\n    \"highlight_waitlist_color\": \"#4c7521\",\r\n\r\n    \"tag_owned_color\": \"#00b75b\",\r\n    \"tag_wishlist_color\": \"#0383b4\",\r\n    \"tag_coupon_color\": \"#c27120\",\r\n    \"tag_inv_gift_color\": \"#b10059\",\r\n    \"tag_inv_guestpass_color\": \"#65449a\",\r\n    \"tag_notinterested_color\": \"#4f4f4f\",\r\n    \"tag_collection_color\": \"#856d0e\",\r\n    \"tag_waitlist_color\": \"#4c7521\",\r\n\r\n    \"highlight_owned\": true,\r\n    \"highlight_wishlist\": true,\r\n    \"highlight_coupon\": false,\r\n    \"highlight_inv_gift\": false,\r\n    \"highlight_inv_guestpass\": false,\r\n    \"highlight_notinterested\": false,\r\n    \"highlight_excludef2p\": false,\r\n    \"highlight_collection\": true,\r\n    \"highlight_waitlist\": true,\r\n\r\n    \"tag_owned\": false,\r\n    \"tag_wishlist\": false,\r\n    \"tag_coupon\": false,\r\n    \"tag_inv_gift\": false,\r\n    \"tag_inv_guestpass\": false,\r\n    \"tag_notinterested\": true,\r\n    \"tag_collection\": false,\r\n    \"tag_waitlist\": false,\r\n    \"tag_short\": false,\r\n\r\n    \"hidetmsymbols\": false,\r\n\r\n    \"showlowestprice\": true,\r\n    \"showlowestprice_onwishlist\": true,\r\n    \"showlowestpricecoupon\": true,\r\n    \"showallstores\": true,\r\n    \"stores\": [],\r\n    \"override_price\": \"auto\",\r\n    \"showregionalprice\": \"mouse\",\r\n    \"regional_countries\": [\"us\", \"gb\", \"ru\", \"br\", \"au\", \"jp\"],\r\n\r\n    \"show_es_homepagetabs\": true,\r\n    \"showmarkettotal\": false,\r\n    \"showsteamrepapi\": true,\r\n    \"showmcus\": true,\r\n    \"showoc\": true,\r\n    \"showhltb\": true,\r\n    \"showyoutube\": true,\r\n    \"showtwitch\": true,\r\n    \"showpcgw\": true,\r\n    \"showcompletionistme\": false,\r\n    \"showprotondb\": false,\r\n    \"showviewinlibrary\": false,\r\n    \"showsteamcardexchange\": false,\r\n    \"showitadlinks\": true,\r\n    \"showsteamdb\": true,\r\n    \"showbartervg\": false,\r\n    \"showastatslink\": true,\r\n    \"showyoutubegameplay\": true,\r\n    \"showyoutubereviews\": true,\r\n    \"showwsgf\": true,\r\n    \"exfgls\": true,\r\n    \"app_custom_link\": [\r\n        {\r\n            \"enabled\": false,\r\n            \"name\": \"Google\",\r\n            \"url\": \"google.com/search?q=[ID]+[NAME]\",\r\n            \"icon\": \"www.google.com/images/branding/product/ico/googleg_lodp.ico\"\r\n        },\r\n    ],\r\n\r\n    \"customize_apppage\": {\r\n        \"recentupdates\": true,\r\n        \"reviews\": true,\r\n        \"about\": true,\r\n        \"contentwarning\": true,\r\n        \"steamchart\": true,\r\n        \"steamspy\": true,\r\n        \"surveys\": true,\r\n        \"sysreq\": true,\r\n        \"legal\": true,\r\n        \"morelikethis\": true,\r\n        \"recommendedbycurators\": true,\r\n        \"customerreviews\": true\r\n    },\r\n\r\n    \"customize_frontpage\": {\r\n        \"featuredrecommended\": true,\r\n        \"specialoffers\": true,\r\n        \"trendingamongfriends\": true,\r\n        \"discoveryqueue\": true,\r\n        \"browsesteam\": true,\r\n        \"curators\": true,\r\n        \"morecuratorrecommendations\": true,\r\n        \"recentlyupdated\": true,\r\n        \"fromdevelopersandpublishersthatyouknow\": true,\r\n        \"popularvrgames\": true,\r\n        \"homepagetabs\": true,\r\n        \"gamesstreamingnow\": true,\r\n        \"under\": true,\r\n        \"updatesandoffers\": true,\r\n        \"homepagesidebar\": true\r\n    },\r\n\r\n    // 'show_keylol_links': false, // not in use, option is commented out\r\n    \"show_package_info\": false,\r\n    \"show_steamchart_info\": true,\r\n    \"show_steamspy_info\": true,\r\n    \"show_early_access\": true,\r\n    \"show_alternative_linux_icon\": false,\r\n    \"show_itad_button\": false,\r\n    \"skip_got_steam\": false,\r\n\r\n    \"installsteam\": \"show\",\r\n    \"openinnewtab\": false,\r\n    \"keepssachecked\": false,\r\n    \"showemptywishlist\": true,\r\n    \"user_notes_app\": true,\r\n    \"user_notes_wishlist\": true,\r\n    \"showwishliststats\": true,\r\n    \"oneclickremovewl\": false,\r\n    \"user_notes\": {},\r\n    \"user_notes_adapter\": \"synced_storage\",\r\n    \"replaceaccountname\": true,\r\n    \"showlanguagewarning\": true,\r\n    \"showlanguagewarninglanguage\": \"english\",\r\n    \"homepage_tab_selection\": \"remember\",\r\n    \"homepage_tab_last\": null,\r\n    \"send_age_info\": true,\r\n    \"removebroadcasts\": false,\r\n    \"mp4video\": false,\r\n    \"horizontalscrolling\": true,\r\n    \"showsupportinfo\": true,\r\n    \"showdrm\": true,\r\n    \"regional_hideworld\": false,\r\n    \"showinvnav\": true,\r\n    \"quickinv\": true,\r\n    \"quickinv_diff\": -0.01,\r\n    \"community_default_tab\": \"\",\r\n    \"showallachievements\": false,\r\n    \"showallstats\": true,\r\n    \"replacecommunityhublinks\": false,\r\n    \"hideannouncementcomments\": false,\r\n    \"showachinstore\": true,\r\n    \"hideactivelistings\": false,\r\n    \"showlowestmarketprice\": true,\r\n    \"hidespamcomments\": false,\r\n    \"spamcommentregex\": \"[\\\\u2500-\\\\u25FF]\",\r\n    \"wlbuttoncommunityapp\": true,\r\n    \"removeguideslanguagefilter\": false,\r\n    \"disablelinkfilter\": false,\r\n    \"sortfriendsby\": \"default_ASC\",\r\n    \"sortreviewsby\": \"default_ASC\",\r\n    \"sortgroupsby\": \"default_ASC\",\r\n    \"show1clickgoo\": true,\r\n    \"show_profile_link_images\": \"gray\",\r\n    \"show_custom_themes\": true,\r\n    \"profile_pinned_bg\": false,\r\n    \"profile_steamrepcn\": true,\r\n    \"profile_steamgifts\": true,\r\n    \"profile_steamtrades\": true,\r\n    \"profile_bartervg\": true,\r\n    \"profile_steamrep\": true,\r\n    \"profile_steamdbcalc\": true,\r\n    \"profile_astats\": true,\r\n    \"profile_backpacktf\": true,\r\n    \"profile_astatsnl\": true,\r\n    \"profile_steamid\": true,\r\n    \"profile_custom_link\": [\r\n        {\r\n            \"enabled\": true,\r\n            \"name\": \"Google\",\r\n            \"url\": \"google.com/search?q=[ID]\",\r\n            \"icon\": \"www.google.com/images/branding/product/ico/googleg_lodp.ico\"\r\n        },\r\n    ],\r\n    \"fav_emoticons\": [],\r\n    \"group_steamgifts\": true,\r\n    \"steamcardexchange\": true,\r\n    \"purchase_dates\": true,\r\n    \"show_badge_progress\": true,\r\n    \"show_coupon\": true,\r\n    \"show_wishlist_link\": true,\r\n    \"show_wishlist_count\": true,\r\n    \"show_progressbar\": true,\r\n    \"show_backtotop\": false,\r\n\r\n    \"profile_showcase_twitch\": true,\r\n    \"profile_showcase_own_twitch\": false,\r\n    \"profile_showcase_twitch_profileonly\": false,\r\n\r\n    \"itad_import_library\": false,\r\n    \"itad_import_wishlist\": false,\r\n    \"add_to_waitlist\": false,\r\n\r\n    \"context_steam_store\": false,\r\n    \"context_steam_market\": false,\r\n    \"context_itad\": false,\r\n    \"context_bartervg\": false,\r\n    \"context_steamdb\": false,\r\n    \"context_steamdb_instant\": false,\r\n    \"context_steam_keys\": false,\r\n});\r\nSyncedStorage.persistent = [\r\n    \"user_notes\",\r\n    \"user_notes_adapter\",\r\n];\r\n\r\nexport {SyncedStorage};\r\n","import {SyncedStorage} from \"./Core/Storage/SyncedStorage\";\r\n\r\nlet initialized = false;\r\n\r\n/**\r\n * DOMPurify setup\r\n * @see https://github.com/cure53/DOMPurify\r\n */\r\nexport default function() {\r\n\r\n    if (initialized) { return; }\r\n    initialized = true;\r\n\r\n    const allowOpenInNewTab = SyncedStorage.get(\"openinnewtab\");\r\n\r\n    /*\r\n     * NOTE FOR ADDON REVIEWER:\r\n     * We are modifying default DOMPurify settings to allow other protocols in URLs\r\n     * and to allow links to safely open in new tabs.\r\n     *\r\n     * We took the original Regex and aded chrome-extension://, moz-extension:// and steam://\r\n     * First two are needed for linking local resources from extension,\r\n     * steam:// protocol is used by Steam store to open their own client (e.g. when you want to launch a game).\r\n     *\r\n     * The addition of the `target` attribute to the allowed attributes is done in order to be able to open links in a new tab.\r\n     * We only allow target=\"_blank\" while adding rel=\"noreferrer noopener\" to prevent child window to access window.opener\r\n     * as described in https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/\r\n     */\r\n\r\n    const purifyConfig = {\r\n        \"ALLOWED_URI_REGEXP\": /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|chrome-extension|moz-extension|steam):|[^a-z]|[a-z+.-]+(?:[^a-z+.\\-:]|$))/i\r\n    };\r\n\r\n    if (allowOpenInNewTab) {\r\n        purifyConfig.ADD_ATTR = [\"target\"];\r\n\r\n        DOMPurify.addHook(\"uponSanitizeAttribute\", (node, data) => {\r\n            if (data.attrName === \"target\") {\r\n                if (data.attrValue === \"_blank\") {\r\n                    node.setAttribute(\"rel\", \"noreferrer noopener\");\r\n                } else {\r\n                    data.keepAttr = false;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    DOMPurify.setConfig(purifyConfig);\r\n}\r\n","\r\nclass LoginError extends Error {\r\n    constructor(type) {\r\n        super(type);\r\n        this.name = \"LoginError\";\r\n    }\r\n}\r\n\r\nclass ServerOutageError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        this.name = \"ServerOutageError\";\r\n    }\r\n}\r\n\r\nclass HTTPError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n    }\r\n}\r\n\r\n\r\nclass FeatureDependencyError extends Error {\r\n    constructor(msg, featureName) {\r\n        super(msg);\r\n        this.featureName = featureName;\r\n    }\r\n}\r\n\r\nconst Errors = {\r\n    \"LoginError\": LoginError,\r\n    \"ServerOutageError\": ServerOutageError,\r\n    \"HTTPError\": HTTPError,\r\n    \"FeatureDependencyError\": FeatureDependencyError\r\n};\r\n\r\nexport {Errors};\r\n","\r\nclass CookieStorage {\r\n\r\n    static get(name, defaultValue) {\r\n        const _name = name.trim();\r\n\r\n        if (!CookieStorage.cache.has(_name)) {\r\n            return defaultValue;\r\n        }\r\n        return CookieStorage.cache.get(_name);\r\n    }\r\n\r\n    static set(name, val, ttl = 60 * 60 * 24 * 365) {\r\n        let _name = name.trim();\r\n        let _val = val.trim();\r\n\r\n        CookieStorage.cache.set(_name, _val);\r\n\r\n        _name = encodeURIComponent(_name);\r\n        _val = encodeURIComponent(_val);\r\n        document.cookie = `${_name}=${_val}; max-age=${ttl}`;\r\n    }\r\n\r\n    static remove(name) {\r\n        let _name = name.trim();\r\n        CookieStorage.cache.delete(_name);\r\n        _name = encodeURIComponent(_name);\r\n        document.cookie = `${_name}; expires=Thu, 01 Jan 1970 00:00:00 GMT`;\r\n    }\r\n\r\n    static init() {\r\n        CookieStorage.cache = new Map();\r\n        for (let [key, val] of document.cookie.split(\";\").map(kv => kv.split(\"=\"))) {\r\n            key = key.trim();\r\n            CookieStorage.cache.set(key, decodeURIComponent(val));\r\n        }\r\n    }\r\n}\r\n\r\nCookieStorage.init();\r\n\r\nexport {CookieStorage};\r\n","\r\nconst ContextType = Object.freeze({\r\n    \"BACKGROUND\": 1,\r\n    \"CONTENT_SCRIPT\": 2,\r\n    \"OPTIONS\": 3,\r\n});\r\n\r\nlet currentContext;\r\nif (browser.extension.getBackgroundPage) {\r\n    const bgPage = browser.extension.getBackgroundPage();\r\n\r\n    currentContext = (bgPage === window)\r\n        ? ContextType.BACKGROUND\r\n        : ContextType.OPTIONS;\r\n} else {\r\n    currentContext = ContextType.CONTENT_SCRIPT;\r\n}\r\n\r\nclass Environment {\r\n\r\n    static isBackgroundScript() {\r\n        return currentContext === ContextType.BACKGROUND;\r\n    }\r\n\r\n    static isContentScript() {\r\n        return currentContext === ContextType.CONTENT_SCRIPT;\r\n    }\r\n\r\n    static isOptions() {\r\n        return currentContext === ContextType.OPTIONS;\r\n    }\r\n}\r\n\r\nexport {Environment};\r\n","import {CookieStorage} from \"../Storage/CookieStorage\";\r\nimport {Environment} from \"../Environment\";\r\n\r\nclass Language {\r\n\r\n    static getCurrentSteamLanguage() {\r\n        if (this._currentSteamLanguage !== null) {\r\n            return this._currentSteamLanguage;\r\n        }\r\n\r\n        for (const script of document.querySelectorAll(\"script[src]\")) {\r\n            const language = new URL(script.src).searchParams.get(\"l\");\r\n            if (language) {\r\n                Language._currentSteamLanguage = language;\r\n                return this._currentSteamLanguage;\r\n            }\r\n        }\r\n\r\n        // In a Content Context, we can check for a cookie\r\n        if (Environment.isContentScript()) {\r\n            Language._currentSteamLanguage = CookieStorage.get(\"Steam_Language\") || null;\r\n        }\r\n\r\n        return this._currentSteamLanguage;\r\n    }\r\n\r\n    static getLanguageCode(language) {\r\n        const code = Language.languages[language];\r\n        return code || \"en\";\r\n    }\r\n\r\n    static isCurrentLanguageOneOf(array) {\r\n        return array.includes(Language.getCurrentSteamLanguage());\r\n    }\r\n}\r\n\r\nLanguage._currentSteamLanguage = null;\r\nLanguage.languages = {\r\n    \"english\": \"en\",\r\n    \"bulgarian\": \"bg\",\r\n    \"czech\": \"cs\",\r\n    \"danish\": \"da\",\r\n    \"dutch\": \"nl\",\r\n    \"finnish\": \"fi\",\r\n    \"french\": \"fr\",\r\n    \"greek\": \"el\",\r\n    \"german\": \"de\",\r\n    \"hungarian\": \"hu\",\r\n    \"italian\": \"it\",\r\n    \"japanese\": \"ja\",\r\n    \"koreana\": \"ko\",\r\n    \"norwegian\": \"no\",\r\n    \"polish\": \"pl\",\r\n    \"portuguese\": \"pt-PT\",\r\n    \"brazilian\": \"pt-BR\",\r\n    \"russian\": \"ru\",\r\n    \"romanian\": \"ro\",\r\n    \"schinese\": \"zh-CN\",\r\n    \"spanish\": \"es-ES\",\r\n    \"latam\": \"es-419\",\r\n    \"swedish\": \"sv-SE\",\r\n    \"tchinese\": \"zh-TW\",\r\n    \"thai\": \"th\",\r\n    \"turkish\": \"tr\",\r\n    \"ukrainian\": \"ua\",\r\n    \"vietnamese\": \"vi\",\r\n};\r\n\r\nexport {Language};\r\n","\r\nclass ExtensionResources {\r\n\r\n    static getURL(pathname) {\r\n        return browser.runtime.getURL(pathname);\r\n    }\r\n\r\n    static get(pathname) {\r\n        return fetch(ExtensionResources.getURL(pathname));\r\n    }\r\n\r\n    static getJSON(pathname) {\r\n        return ExtensionResources.get(pathname).then(r => r.json());\r\n    }\r\n\r\n    static getText(pathname) {\r\n        return ExtensionResources.get(pathname).then(r => r.text());\r\n    }\r\n}\r\n\r\nexport {ExtensionResources};\r\n","import {BackgroundSimple} from \"../BackgroundSimple\";\r\nimport {ExtensionResources} from \"../ExtensionResources\";\r\nimport {Language} from \"./Language\";\r\nimport {SyncedStorage} from \"../Storage/SyncedStorage\";\r\n\r\n\r\nclass Localization {\r\n\r\n    static loadLocalization(code) {\r\n        return ExtensionResources.getJSON(`/localization/${code}.json`);\r\n    }\r\n\r\n    static init() {\r\n        if (Localization._promise) { return Localization._promise; }\r\n\r\n        let currentSteamLanguage = Language.getCurrentSteamLanguage();\r\n        const storedSteamLanguage = SyncedStorage.get(\"language\");\r\n        if (currentSteamLanguage === null) {\r\n            currentSteamLanguage = storedSteamLanguage;\r\n        } else if (currentSteamLanguage !== storedSteamLanguage) {\r\n            SyncedStorage.set(\"language\", currentSteamLanguage);\r\n            BackgroundSimple.action(\"clearpurchases\");\r\n        }\r\n\r\n        function deepAssign(target, source) {\r\n\r\n            // Object.assign() but deep-assigning objects recursively\r\n            for (const [key, val] of Object.entries(source)) {\r\n                if (typeof target[key] === \"undefined\") {\r\n                    console.warn(\"The key %s doesn't exist in the English localization file\", key);\r\n                    continue;\r\n                }\r\n                if (typeof val === \"object\") {\r\n                    deepAssign(target[key], val);\r\n                } else if (val !== \"\") {\r\n                    target[key] = val;\r\n                }\r\n            }\r\n            return target;\r\n        }\r\n\r\n        const local = Language.getLanguageCode(currentSteamLanguage);\r\n        const codes = [\"en\"];\r\n        if (local !== null && local !== \"en\") {\r\n            codes.push(local);\r\n        }\r\n        Localization._promise = Promise.all(\r\n            codes.map(lc => Localization.loadLocalization(lc))\r\n        ).then(([english, local]) => {\r\n            Localization.str = english;\r\n            if (local) {\r\n                deepAssign(Localization.str, local);\r\n            }\r\n            return Localization.str;\r\n        });\r\n        return Localization._promise;\r\n    }\r\n\r\n    static then(onDone, onCatch) {\r\n        return Localization.init().then(onDone, onCatch);\r\n    }\r\n\r\n    static getString(key) {\r\n\r\n        // Source: http://stackoverflow.com/a/24221895\r\n        const path = key.split(\".\").reverse();\r\n        let current = Localization.str;\r\n\r\n        while (path.length) {\r\n            if (typeof current !== \"object\") {\r\n                return null;\r\n            }\r\n            current = current[path.pop()];\r\n        }\r\n        return current;\r\n    }\r\n}\r\n\r\nLocalization._promise = null;\r\n\r\n\r\nexport {Localization};\r\n","\r\nclass BackgroundSimple {\r\n    static message(message) {\r\n        return browser.runtime.sendMessage(message);\r\n    }\r\n\r\n    static action(requested, ...params) {\r\n        if (!params.length) { return this.message({\"action\": requested}); }\r\n        return this.message({\"action\": requested, \"params\": params});\r\n    }\r\n}\r\n\r\nexport {BackgroundSimple};\r\n","\r\nimport {Storage} from \"./Storage\";\r\nimport {Environment} from \"../Environment\";\r\n\r\nclass LocalStorage extends Storage {\r\n\r\n    static async init() {\r\n        await super.init();\r\n\r\n        if (this === LocalStorage) {\r\n            // TODO Remove after some versions\r\n            return this.migrate();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static async migrate() {\r\n\r\n        const migrationDone = this.get(\"local_storage_migration\");\r\n\r\n        let type;\r\n\r\n        if (location.hostname === \"store.steampowered.com\") {\r\n            type = \"store\";\r\n        } else if (location.hostname === \"steamcommunity.com\") {\r\n            type = \"community\";\r\n        } else if (Environment.isContentScript()) {\r\n            return null;\r\n        } else {\r\n            type = \"extension\";\r\n        }\r\n\r\n        if (migrationDone[type]) { return null; }\r\n\r\n        await Promise.all(Object.keys(LocalStorage.defaults).map(async key => {\r\n\r\n            let value = localStorage.getItem(key);\r\n            if (value === null) { return; }\r\n\r\n            try {\r\n                value = JSON.parse(value);\r\n            } catch (err) {\r\n                console.error(\"Can't parse value\", value);\r\n                throw err;\r\n            }\r\n\r\n            await LocalStorage.set(key, value);\r\n            localStorage.removeItem(key);\r\n        }));\r\n\r\n        migrationDone[type] = true;\r\n        return LocalStorage.set(\"local_storage_migration\", migrationDone);\r\n    }\r\n}\r\n\r\nLocalStorage._adapter = browser.storage.local;\r\n\r\nLocalStorage.defaults = Object.freeze({\r\n    \"access_token\": null,\r\n    \"lastItadImport\": {\"from\": null, \"to\": null},\r\n    \"login\": {\"steamId\": null, \"profilePath\": null},\r\n    \"storeCountry\": null,\r\n    \"expand_slider\": false,\r\n    \"es_guide_tags\": {}, // TODO remove prefix\r\n    \"market_stats\": {\"startListing\": null, \"purchaseTotal\": 0, \"saleTotal\": 0},\r\n    \"popular_refresh\": false,\r\n    \"workshop_state\": \"\",\r\n    \"playback_hd\": false,\r\n    \"show_review_section\": true,\r\n    \"steampeek\": false,\r\n    \"support_info\": null,\r\n    \"hide_login_warn_store\": false,\r\n    \"hide_login_warn_community\": false,\r\n    \"review_filters\": {},\r\n    \"local_storage_migration\": {\"store\": false, \"community\": false, \"extension\": false},\r\n});\r\n\r\nexport {LocalStorage};\r\n","import {SyncedStorage} from \"./Storage/SyncedStorage\";\r\n\r\nconst ctxPermissions = __BROWSER__ === \"firefox\" ? [] : [\"contextMenus\"];\r\n\r\nconst PermissionOptions = Object.freeze({\r\n    \"context_steam_store\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n    \"context_steam_market\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n    \"context_itad\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n    \"context_bartervg\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n    \"context_steamdb\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n    \"context_steamdb_instant\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n    \"context_steam_keys\": {\r\n        \"persistent\": true,\r\n        \"permissions\": ctxPermissions,\r\n    },\r\n});\r\n\r\nclass Permissions {\r\n\r\n    /**\r\n     * @return Promise\r\n     */\r\n    static contains(permissionList) {\r\n        return browser.permissions.contains({\"permissions\": permissionList});\r\n    }\r\n\r\n    /**\r\n     * @return Promise\r\n     */\r\n    static request(permissionList) {\r\n        return browser.permissions.request({\"permissions\": permissionList});\r\n    }\r\n\r\n    /**\r\n     * @return Promise\r\n     */\r\n    static remove(permissionList) {\r\n        if (permissionList.includes(\"contextMenus\")) {\r\n            browser.contextMenus.removeAll();\r\n        }\r\n        return browser.permissions.remove({\"permissions\": permissionList});\r\n    }\r\n\r\n    static async when(permission, onAdded, onRemoved) {\r\n        if (onAdded) {\r\n            if (await Permissions.contains([permission])) {\r\n                onAdded();\r\n            }\r\n\r\n            browser.permissions.onAdded.addListener(p => {\r\n                if (p.permissions.includes(permission)) {\r\n                    onAdded();\r\n                }\r\n            });\r\n        }\r\n\r\n        if (onRemoved) {\r\n            browser.permissions.onRemoved.addListener(p => {\r\n                if (p.permissions.includes(permission)) {\r\n                    onRemoved();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    static requestOption(option) {\r\n        return Permissions.request(PermissionOptions[option].permissions);\r\n    }\r\n\r\n    static removeOption(optionToRemove) {\r\n\r\n        // If any of the permissions is in use by another option, don't remove.\r\n        const unusedPermissions = Permissions._getUnusedPermissions(optionToRemove);\r\n        if (unusedPermissions.length === 0) {\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n        return Permissions.remove(unusedPermissions);\r\n    }\r\n\r\n    static _getUnusedPermissions(option) {\r\n        const used = new Set();\r\n        for (const [key, setup] of Object.entries(PermissionOptions)) {\r\n            if (option === key || (setup.persistent && !SyncedStorage.get(key))) {\r\n                continue;\r\n            }\r\n\r\n            for (const p of setup.permissions) {\r\n                used.add(p);\r\n            }\r\n        }\r\n\r\n        const unused = new Set();\r\n        for (const p of PermissionOptions[option].permissions) {\r\n            if (!used.has(p)) {\r\n                unused.add(p);\r\n            }\r\n        }\r\n\r\n        return Array.from(unused.values());\r\n    }\r\n}\r\n\r\nexport {PermissionOptions, Permissions};\r\n","import {Localization, Permissions, SyncedStorage} from \"../../modulesCore\";\r\n\r\nclass ContextMenu {\r\n\r\n    static onClick(info) {\r\n        const url = ContextMenu.queryLinks[info.menuItemId];\r\n        if (!url) { return; }\r\n\r\n        let query = info.selectionText.trim();\r\n\r\n        if (info.menuItemId === \"context_steam_keys\") {\r\n            const steamKeys = query.match(/[A-Z0-9]{5}(-[A-Z0-9]{5}){2}/g);\r\n\r\n            // Set the query to matched keys if any, otherwise display the selected text anyway\r\n            if (Array.isArray(steamKeys)) {\r\n                query = steamKeys.join(\",\");\r\n            }\r\n        }\r\n\r\n        browser.tabs.create({\"url\": url.replace(\"__query__\", encodeURIComponent(query))});\r\n    }\r\n\r\n    static async build() {\r\n        await SyncedStorage;\r\n        await Localization;\r\n\r\n        for (const option of Object.keys(ContextMenu.queryLinks)) {\r\n            if (!SyncedStorage.get(option)) { continue; }\r\n\r\n            browser.contextMenus.create({\r\n                \"id\": option,\r\n                \"title\": Localization.str.options[option].replace(\"__query__\", \"%s\"),\r\n                \"contexts\": [\"selection\"]\r\n            },\r\n\r\n            /*\r\n             * TODO don't recreate the context menu entries on each change, only update\r\n             * the affected entry (which should also prevent this error)\r\n             * Error when you create an entry with duplicate id\r\n             */\r\n            () => chrome.runtime.lastError);\r\n        }\r\n    }\r\n\r\n    static async update() {\r\n        if (!await Permissions.contains([\"contextMenus\"])) { return null; }\r\n\r\n        await browser.contextMenus.removeAll();\r\n        return ContextMenu.build();\r\n    }\r\n}\r\n\r\nContextMenu.queryLinks = {\r\n    \"context_steam_store\": \"https://store.steampowered.com/search/?term=__query__\",\r\n    \"context_steam_market\": \"https://steamcommunity.com/market/search?q=__query__\",\r\n    \"context_itad\": \"https://isthereanydeal.com/search/?q=__query__\",\r\n    \"context_bartervg\": \"https://barter.vg/search?q=__query__\",\r\n    \"context_steamdb\": \"https://steamdb.info/search/?q=__query__\",\r\n    \"context_steamdb_instant\": \"https://steamdb.info/instantsearch/?query=__query__\",\r\n    \"context_steam_keys\": \"https://store.steampowered.com/account/registerkey?key=__query__\"\r\n};\r\n\r\nexport {ContextMenu};\r\n","class Timer {\r\n\r\n    constructor(duration) {\r\n        this._promise = new Promise(resolve => {\r\n            this._id = setTimeout(() => { resolve(); }, duration);\r\n        });\r\n    }\r\n\r\n    then(onSuccess, onFail) {\r\n        if (this._promise) {\r\n            return this._promise.then(onSuccess, onFail);\r\n        }\r\n\r\n        throw new Error(\"Timer has been cleared before\");\r\n    }\r\n\r\n    clear() {\r\n        clearTimeout(this._id);\r\n        this._promise = null;\r\n    }\r\n}\r\n\r\nclass ResettableTimer {\r\n\r\n    constructor(onDone, duration) {\r\n        this.onDone = onDone;\r\n        this.duration = duration;\r\n\r\n        this.reset();\r\n    }\r\n\r\n    get running() { return this._running; }\r\n\r\n    reset() {\r\n        if (typeof this._id !== \"undefined\") {\r\n            clearTimeout(this._id);\r\n        }\r\n\r\n        this._id = setTimeout(async() => {\r\n            await this.onDone();\r\n            this._running = false;\r\n        }, this.duration);\r\n\r\n        this._running = true;\r\n    }\r\n}\r\n\r\nclass TimeUtils {\r\n\r\n    static timer(duration) {\r\n        return new Timer(duration);\r\n    }\r\n\r\n    static resettableTimer(onDone, duration) {\r\n        return new ResettableTimer(onDone, duration);\r\n    }\r\n\r\n    static now() {\r\n        return Math.trunc(Date.now() / 1000);\r\n    }\r\n}\r\n\r\nexport {TimeUtils};\r\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import {Info} from \"../../Core/Info\";\r\nimport {TimeUtils} from \"../../Core/Utils/TimeUtils\";\r\nimport {openDB} from \"idb\";\r\n\r\nclass IndexedDB {\r\n\r\n    static init() {\r\n        if (IndexedDB._promise) { return IndexedDB._promise; }\r\n        IndexedDB._promise = openDB(\"Augmented Steam\", Info.db_version, {\r\n            upgrade(db, oldVersion, newVersion, tx) {\r\n                if (oldVersion < 1) {\r\n                    db.createObjectStore(\"coupons\").createIndex(\"appid\", \"appids\", {\"unique\": false, \"multiEntry\": true});\r\n                    db.createObjectStore(\"giftsAndPasses\").createIndex(\"appid\", \"\", {\"unique\": false, \"multiEntry\": true});\r\n                    db.createObjectStore(\"items\");\r\n                    db.createObjectStore(\"earlyAccessAppids\");\r\n                    db.createObjectStore(\"purchases\");\r\n                    db.createObjectStore(\"dynamicStore\").createIndex(\"appid\", \"\", {\"unique\": false, \"multiEntry\": true});\r\n                    db.createObjectStore(\"packages\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"storePageData\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"profiles\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"rates\");\r\n                    db.createObjectStore(\"notes\");\r\n                    db.createObjectStore(\"collection\");\r\n                    db.createObjectStore(\"waitlist\");\r\n                    db.createObjectStore(\"itadImport\");\r\n                }\r\n\r\n                if (oldVersion < 2) {\r\n                    db.createObjectStore(\"workshopFileSizes\").createIndex(\"expiry\", \"expiry\");\r\n                    db.createObjectStore(\"reviews\").createIndex(\"expiry\", \"expiry\");\r\n                }\r\n\r\n                if (oldVersion < 3) {\r\n                    db.createObjectStore(\"expiries\").createIndex(\"expiry\", \"\");\r\n\r\n                    tx.objectStore(\"packages\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"storePageData\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"profiles\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"workshopFileSizes\").deleteIndex(\"expiry\");\r\n                    tx.objectStore(\"reviews\").deleteIndex(\"expiry\");\r\n                }\r\n            },\r\n            blocked() {\r\n                console.error(\"Failed to upgrade database, there is already an open connection\");\r\n            },\r\n        })\r\n            .then(db => { IndexedDB.db = db; })\r\n            .then(IndexedDB._deleteOldData);\r\n\r\n        return IndexedDB._promise;\r\n    }\r\n\r\n    static then(onDone, onCatch) {\r\n        return IndexedDB.init().then(onDone, onCatch);\r\n    }\r\n\r\n    static async _deleteOldData() {\r\n        const expiryStore = IndexedDB.db.transaction(\"expiries\", \"readwrite\").store;\r\n        let cursor = await expiryStore.index(\"expiry\").openCursor(IDBKeyRange.upperBound(TimeUtils.now()));\r\n        const expired = [];\r\n        const stores = {};\r\n        const promises = [];\r\n\r\n        while (cursor) {\r\n            expired.push(cursor.primaryKey);\r\n            promises.push(expiryStore.delete(cursor.primaryKey));\r\n            cursor = await cursor.continue();\r\n        }\r\n\r\n        for (const expiryKey of expired) {\r\n            const [storeName, key] = expiryKey.split(/_/);\r\n            if (!stores[storeName]) {\r\n                stores[storeName] = [];\r\n            }\r\n\r\n            if (key) {\r\n                stores[storeName].push(key);\r\n            }\r\n        }\r\n\r\n        for (const [storeName, keys] of Object.entries(stores)) {\r\n\r\n            const dataStore = IndexedDB.db.transaction(storeName, \"readwrite\").store;\r\n\r\n            if (IndexedDB.timestampedStores.has(storeName)) {\r\n                promises.push(dataStore.clear());\r\n            } else {\r\n                promises.push(Promise.all(keys.map(key => {\r\n\r\n                    const strKeyPromise = dataStore.delete(key);\r\n\r\n                    const nmbKey = Number(key);\r\n                    if (nmbKey) {\r\n                        return Promise.all([\r\n                            strKeyPromise,\r\n                            dataStore.delete(nmbKey),\r\n                        ]);\r\n                    }\r\n\r\n                    return strKeyPromise;\r\n                })));\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    static async put(storeName, data, {ttl, multiple = typeof data === \"object\"} = {}) {\r\n        const tx = IndexedDB.db.transaction(storeName, \"readwrite\");\r\n\r\n        let expiry;\r\n        const expiryKeys = [];\r\n\r\n        const cached = IndexedDB.cacheObjectStores.has(storeName);\r\n        const timestampedEntry = IndexedDB.timestampedEntriesStores.has(storeName);\r\n\r\n        function nonAssociativeData(data) {\r\n            let promise;\r\n            if (tx.store.autoIncrement || tx.store.keyPath !== null) {\r\n                promise = tx.store.put(data);\r\n            } else {\r\n                promise = tx.store.put(null, data);\r\n            }\r\n            promise.then(key => {\r\n                if (timestampedEntry) { expiryKeys.push(`${storeName}_${key}`); }\r\n            });\r\n        }\r\n\r\n        if (cached) {\r\n            const _ttl = ttl || IndexedDB.cacheObjectStores.get(storeName);\r\n            expiry = TimeUtils.now() + _ttl;\r\n\r\n            if (!timestampedEntry) {\r\n                expiryKeys.push(storeName);\r\n            }\r\n        }\r\n\r\n        if (multiple) {\r\n            if (Array.isArray(data)) {\r\n                data.forEach(nonAssociativeData);\r\n            } else if (typeof data === \"object\") {\r\n                const entries = data instanceof Map ? data.entries() : Object.entries(data);\r\n                for (const [key, value] of entries) {\r\n                    tx.store.put(value, key).then(key => {\r\n                        if (timestampedEntry) { expiryKeys.push(`${storeName}_${key}`); }\r\n                    });\r\n                }\r\n            } else {\r\n                console.warn(\"multiple parameter specified but the data is a primitive\");\r\n            }\r\n        } else {\r\n            nonAssociativeData(data);\r\n        }\r\n\r\n        await tx.done;\r\n\r\n        const expiryTx = IndexedDB.db.transaction(\"expiries\", \"readwrite\");\r\n\r\n        for (const key of expiryKeys) {\r\n            expiryTx.store.put(expiry, key);\r\n        }\r\n\r\n        return expiryTx.done;\r\n    }\r\n\r\n    static async get(storeName, key, options = {}) {\r\n        const keys = IndexedDB._asArray(key);\r\n\r\n        await Promise.all([\r\n            IndexedDB.checkStoreExpiry(storeName, options),\r\n            IndexedDB.checkEntryExpiry(storeName, keys, options),\r\n        ]);\r\n\r\n        const store = IndexedDB.db.transaction(storeName).store;\r\n        const values = await Promise.all(keys.map(key => store.get(key)));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static async getAll(storeName, options = {}) {\r\n        const keys = [];\r\n        const values = [];\r\n        let cursor;\r\n\r\n        await IndexedDB.checkStoreExpiry(storeName, options);\r\n\r\n        if (IndexedDB.timestampedEntriesStores.has(storeName)) {\r\n            await IndexedDB.checkEntryExpiry(storeName, await IndexedDB.db.getAllKeys(storeName), options);\r\n        }\r\n\r\n        cursor = await IndexedDB.db.transaction(storeName).store.openCursor();\r\n\r\n        while (cursor) {\r\n            keys.push(cursor.key);\r\n            values.push(cursor.value);\r\n\r\n            cursor = await cursor.continue();\r\n        }\r\n\r\n        return IndexedDB._resultsAsObject(keys, await Promise.all(values));\r\n    }\r\n\r\n    static async getFromIndex(storeName, indexName, key, options = {}) {\r\n\r\n        // It doesn't make sense to query on an index from a timestamped entry store, since the data is not complete\r\n        if (IndexedDB.timestampedEntriesStores.has(storeName)) { return null; }\r\n\r\n        await IndexedDB.checkStoreExpiry(storeName, options);\r\n\r\n        const keys = IndexedDB._asArray(key);\r\n        const index = IndexedDB.db.transaction(storeName).store.index(indexName);\r\n\r\n        const values = await Promise.all(keys.map(key => {\r\n            if (options.asKey) {\r\n                if (options.all) {\r\n                    return index.getAllKeys(key);\r\n                }\r\n                return index.getKey(key);\r\n            }\r\n\r\n            if (options.all) {\r\n                return index.getAll(key);\r\n            }\r\n\r\n            return index.get(key);\r\n        }));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static async indexContainsKey(storeName, indexName, key, options = {}) {\r\n\r\n        // It doesn't make sense to query on an index from a timestamped entry store, since the data is not complete\r\n        if (IndexedDB.timestampedEntriesStores.has(storeName)) { return null; }\r\n\r\n        await IndexedDB.checkStoreExpiry(storeName, options);\r\n\r\n        const keys = IndexedDB._asArray(key);\r\n        const index = IndexedDB.db.transaction(storeName).store.index(indexName);\r\n\r\n        const values = await Promise.all(keys.map(key => index.openKeyCursor(key)\r\n            .then(cursor => Boolean(cursor))));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static delete(storeName, key) {\r\n\r\n        const keys = IndexedDB._asArray(key);\r\n        const dataStore = IndexedDB.db.transaction(storeName, \"readwrite\").store;\r\n        let expiryStore;\r\n\r\n        if (IndexedDB.cacheObjectStores.has(storeName)) {\r\n            expiryStore = IndexedDB.db.transaction(\"expiries\", \"readwrite\").store;\r\n        }\r\n\r\n        return Promise.all(keys.map(key => {\r\n            const dataPromise = dataStore.delete(key);\r\n            if (expiryStore) {\r\n                return Promise.all([\r\n                    dataPromise,\r\n                    expiryStore.delete(IndexedDB.timestampedStores.has(storeName) ? storeName : `${storeName}_${key}`)\r\n                ]);\r\n            }\r\n            return dataPromise;\r\n        }));\r\n    }\r\n\r\n    static clear(storeName = Array.from(IndexedDB.cacheObjectStores.keys())) {\r\n        const storeNames = IndexedDB._asArray(storeName);\r\n        let expiryStore;\r\n\r\n        if (storeNames.some(storeName => IndexedDB.cacheObjectStores.has(storeName))) {\r\n            expiryStore = IndexedDB.db.transaction(\"expiries\", \"readwrite\").store;\r\n        }\r\n\r\n        return Promise.all(storeNames.map(storeName => {\r\n            const clearPromise = IndexedDB.db.clear(storeName);\r\n\r\n            if (IndexedDB.cacheObjectStores.has(storeName)) {\r\n\r\n                let expiryKey;\r\n                if (IndexedDB.timestampedStores.has(storeName)) {\r\n                    expiryKey = storeName;\r\n                } else {\r\n                    expiryKey = IDBKeyRange.bound(\r\n                        `${storeName}_`,\r\n                        `${storeName}${String.fromCharCode(\"_\".charCodeAt(0) + 1)}`,\r\n                        false,\r\n                        true\r\n                    );\r\n                }\r\n\r\n                return Promise.all([\r\n                    clearPromise,\r\n                    expiryStore.delete(expiryKey),\r\n                ]);\r\n            }\r\n\r\n            return clearPromise;\r\n        }));\r\n    }\r\n\r\n    static async contains(storeName, key, options = {}) {\r\n        const keys = IndexedDB._asArray(key);\r\n\r\n        await Promise.all([\r\n            IndexedDB.checkStoreExpiry(storeName, options),\r\n            IndexedDB.checkEntryExpiry(storeName, keys, options),\r\n        ]);\r\n\r\n        const store = IndexedDB.db.transaction(storeName).store;\r\n\r\n        const values = await Promise.all(keys.map(key => store.openCursor(key)\r\n            .then(cursor => Boolean(cursor))));\r\n\r\n        return Array.isArray(key) ? IndexedDB._resultsAsObject(keys, values) : values[0];\r\n    }\r\n\r\n    static async checkEntryExpiry(storeName, keys, options = {}) {\r\n\r\n        if (!IndexedDB.timestampedEntriesStores.has(storeName)) { return null; }\r\n\r\n        const tx = IndexedDB.db.transaction(\"expiries\");\r\n        const expired = [];\r\n\r\n        for (const key of keys) {\r\n            tx.store.get(`${storeName}_${key}`).then(expiry => {\r\n                if (!expiry || IndexedDB.isExpired(expiry)) {\r\n                    expired.push(key);\r\n                }\r\n            });\r\n        }\r\n\r\n        await tx.done;\r\n\r\n        if (options.preventFetch) {\r\n            const dataTx = IndexedDB.db.transaction(storeName, \"readwrite\");\r\n\r\n            for (const key of expired) {\r\n                dataTx.store.delete(key);\r\n            }\r\n\r\n            return dataTx.done;\r\n        }\r\n\r\n        return Promise.all(expired.map(key => IndexedDB.fetchUpdatedData(storeName, key, options.params)));\r\n    }\r\n\r\n    static async checkStoreExpiry(storeName, options = {}) {\r\n\r\n        if (!IndexedDB.timestampedStores.has(storeName)) { return null; }\r\n\r\n        const expiry = await IndexedDB.db.get(\"expiries\", storeName);\r\n        let expired = true;\r\n\r\n        if (expiry) {\r\n            expired = IndexedDB.isExpired(expiry);\r\n        }\r\n\r\n        if (expired) {\r\n            await IndexedDB.clear(storeName);\r\n            if (!options.preventFetch) {\r\n                return IndexedDB.fetchUpdatedData(storeName, null, options.params);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    static fetchUpdatedData(storeName, key, params) {\r\n\r\n        const requestKey = key ? `${storeName}_${key}` : storeName;\r\n        if (IndexedDB._ongoingRequests.has(requestKey)) {\r\n            return IndexedDB._ongoingRequests.get(requestKey);\r\n        }\r\n\r\n        let req;\r\n        const timestampedStore = IndexedDB.timestampedStores.has(storeName);\r\n        if (timestampedStore) {\r\n            req = IndexedDB.objStoreFetchFns.get(storeName)({params});\r\n        } else {\r\n            req = IndexedDB.objStoreFetchFns.get(storeName)({params, key});\r\n        }\r\n        req = req\r\n            .catch(async err => {\r\n                console.group(\"Object store data\");\r\n                if (key) {\r\n                    console.error(\"Failed to update key %s of object store %s\", key, storeName);\r\n                } else {\r\n                    console.error(\"Failed to update object store %s\", storeName);\r\n                }\r\n                console.error(err);\r\n                console.groupEnd();\r\n\r\n                // Wait some seconds before retrying\r\n                await IndexedDB.db.put(\"expiries\", TimeUtils.now() + 60, timestampedStore ? storeName : `${storeName}_${key}`);\r\n\r\n                throw err;\r\n            })\r\n            .finally(() => IndexedDB._ongoingRequests.delete(requestKey));\r\n        IndexedDB._ongoingRequests.set(requestKey, req);\r\n        return req;\r\n    }\r\n\r\n    static isExpired(expiry) {\r\n        return expiry <= TimeUtils.now();\r\n    }\r\n\r\n    static _asArray(key) {\r\n        return Array.isArray(key) ? key : [key];\r\n    }\r\n\r\n    static _resultsAsObject(keys, values) {\r\n        return keys.reduce((acc, key, i) => {\r\n            acc[key] = values[i];\r\n            return acc;\r\n        }, {});\r\n    }\r\n}\r\nIndexedDB._promise = null;\r\nIndexedDB._ongoingRequests = new Map();\r\n\r\n/*\r\n *  Object stores in this map won't get checked\r\n *  for timestamps if cached.\r\n *  Instead of checking the single entry, the object store itself has\r\n *  a entry named \"expiry\".\r\n *\r\n *  This allows us to reduce the overhead of having one timestamp for\r\n *  each individual entry, although they're basically fetched during\r\n *  the same time.\r\n */\r\nIndexedDB.timestampedStores = new Map([\r\n    [\"coupons\", 60 * 60],\r\n    [\"giftsAndPasses\", 60 * 60],\r\n    [\"items\", 60 * 60],\r\n    [\"earlyAccessAppids\", 60 * 60],\r\n    [\"purchases\", 24 * 60 * 60],\r\n    [\"dynamicStore\", 15 * 60],\r\n    [\"rates\", 60 * 60],\r\n    [\"collection\", 15 * 60],\r\n    [\"waitlist\", 15 * 60],\r\n]);\r\n\r\nIndexedDB.timestampedEntriesStores = new Map([\r\n    [\"packages\", 7 * 24 * 60 * 60],\r\n    [\"storePageData\", 60 * 60],\r\n    [\"profiles\", 24 * 60 * 60],\r\n    [\"workshopFileSizes\", 5 * 24 * 60 * 60],\r\n    [\"reviews\", 60 * 60],\r\n]);\r\n\r\nIndexedDB.cacheObjectStores = new Map([...IndexedDB.timestampedStores, ...IndexedDB.timestampedEntriesStores]);\r\n\r\nexport {IndexedDB};\r\n","\r\nclass GameId {\r\n\r\n    static parseId(id) {\r\n        if (!id) { return null; }\r\n\r\n        const intId = parseInt(id);\r\n        if (!intId) { return null; }\r\n\r\n        return intId;\r\n    }\r\n\r\n    static getAppid(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLElement) {\r\n            const appid = _text.dataset.dsAppid;\r\n            if (appid) { return GameId.parseId(appid); }\r\n            _text = _text.href;\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        // app, games (legacy official group page), market/listing\r\n        const m = _text.match(/(?:store\\.steampowered|steamcommunity)\\.com\\/(?:app|games|market\\/listings)\\/(\\d+)\\/?/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getSubid(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLElement) {\r\n            const subid = _text.dataset.dsPackageid;\r\n            if (subid) { return GameId.parseId(subid); }\r\n            _text = _text.href;\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        const m = _text.match(/(?:store\\.steampowered|steamcommunity)\\.com\\/sub\\/(\\d+)\\/?/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getBundleid(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLElement) {\r\n            const bundleid = _text.dataset.dsBundleid;\r\n            if (bundleid) { return GameId.parseId(bundleid); }\r\n            _text = _text.href;\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        const m = _text.match(/(?:store\\.steampowered|steamcommunity)\\.com\\/bundle\\/(\\d+)\\/?/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static trimStoreId(storeId) {\r\n        return Number(storeId.slice(storeId.indexOf(\"/\") + 1));\r\n    }\r\n\r\n    static getAppidImgSrc(text) {\r\n        let _text = text;\r\n\r\n        if (!_text) { return null; }\r\n\r\n        if (_text instanceof HTMLImageElement) {\r\n            if (_text.hasAttribute(\"src\")) {\r\n                _text = _text.getAttribute(\"src\");\r\n            } else {\r\n                _text = _text.dataset.imageUrl;\r\n            }\r\n            if (!_text) { return null; }\r\n        }\r\n\r\n        // TODO support Steam's CDN option\r\n        const m = _text.match(/(?:cdn\\.(?:akamai|cloudflare)\\.steamstatic\\.com\\/steam|steamcdn-a\\.akamaihd\\.net\\/steam|steamcommunity\\/public\\/images)\\/apps\\/(\\d+)\\//);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getAppidUriQuery(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/appid=(\\d+)/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getAppids(text) {\r\n        const regex = /(?:store\\.steampowered|steamcommunity)\\.com\\/app\\/(\\d+)\\/?/g;\r\n        const res = [];\r\n        let m;\r\n        while ((m = regex.exec(text)) !== null) {\r\n            const id = GameId.parseId(m[1]);\r\n            if (id) {\r\n                res.push(id);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    static getAppidFromId(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/game_(\\d+)/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n\r\n    static getAppidFromGameCard(text) {\r\n        if (!text) { return null; }\r\n        const m = text.match(/\\/gamecards\\/(\\d+)/);\r\n        return m && GameId.parseId(m[1]);\r\n    }\r\n}\r\n\r\nexport {GameId};\r\n","// TODO Accept NodeLists to insert HTML for every node in the list\r\nclass HTML {\r\n\r\n    static escape(str) {\r\n\r\n        // @see https://stackoverflow.com/a/4835406\r\n        const map = {\r\n            \"&\": \"&amp;\",\r\n            \"<\": \"&lt;\",\r\n            \">\": \"&gt;\",\r\n            '\"': \"&quot;\",\r\n            \"'\": \"&#039;\"\r\n        };\r\n\r\n        return str.replace(/[&<>\"']/g, (m) => { return map[m]; });\r\n    }\r\n\r\n    static fragment(html) {\r\n        const template = document.createElement(\"template\");\r\n        template.innerHTML = DOMPurify.sanitize(html);\r\n        return template.content;\r\n    }\r\n\r\n    static element(html) {\r\n        return HTML.fragment(html).firstElementChild;\r\n    }\r\n\r\n    static _getNode(node) {\r\n        let _node = node;\r\n\r\n        if (typeof _node == \"undefined\" || _node === null) {\r\n            console.warn(`${_node} is not an Element.`);\r\n            return null;\r\n        }\r\n        if (typeof _node == \"string\") {\r\n            _node = document.querySelector(_node);\r\n        }\r\n        if (!(_node instanceof Element)) {\r\n            console.warn(`${_node} is not an Element.`);\r\n            return null;\r\n        }\r\n\r\n        return _node;\r\n    }\r\n\r\n    static inner(node, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            _node.innerHTML = DOMPurify.sanitize(html);\r\n        }\r\n        return _node;\r\n    }\r\n\r\n    static replace(node, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            _node.outerHTML = DOMPurify.sanitize(html);\r\n        }\r\n        return _node;\r\n    }\r\n\r\n    static wrap(wrapper, startEl, endEl = startEl) {\r\n        const _startEl = HTML._getNode(startEl);\r\n\r\n        if (!_startEl) { return null; }\r\n\r\n        const _endEl = endEl === null ? _startEl.parentElement.lastElementChild : HTML._getNode(endEl);\r\n\r\n        const wrappedNodes = [_startEl];\r\n        for (let cur = _startEl; cur.nextElementSibling !== null && cur !== _endEl; cur = cur.nextElementSibling) {\r\n            wrappedNodes.push(cur.nextElementSibling);\r\n        }\r\n\r\n        const _wrapper = HTML.element(wrapper);\r\n        _startEl.replaceWith(_wrapper);\r\n        _wrapper.append(...wrappedNodes);\r\n        return _wrapper;\r\n    }\r\n\r\n    static adjacent(node, position, html) {\r\n        const _node = HTML._getNode(node);\r\n\r\n        if (_node) {\r\n            _node.insertAdjacentHTML(position, DOMPurify.sanitize(html));\r\n        }\r\n        return _node;\r\n    }\r\n\r\n    static beforeBegin(node, html) {\r\n        HTML.adjacent(node, \"beforebegin\", html);\r\n    }\r\n\r\n    static afterBegin(node, html) {\r\n        HTML.adjacent(node, \"afterbegin\", html);\r\n    }\r\n\r\n    static beforeEnd(node, html) {\r\n        HTML.adjacent(node, \"beforeend\", html);\r\n    }\r\n\r\n    static afterEnd(node, html) {\r\n        HTML.adjacent(node, \"afterend\", html);\r\n    }\r\n}\r\n\r\nexport {HTML};\r\n","import {HTML} from \"./Html\";\r\n\r\nclass HTMLParser {\r\n\r\n    static clearSpecialSymbols(string) {\r\n        return string.replace(/[\\u00AE\\u00A9\\u2122]/g, \"\");\r\n    }\r\n\r\n    static htmlToDOM(html) {\r\n        return HTML.fragment(html);\r\n    }\r\n\r\n    static htmlToElement(html) {\r\n        return HTML.element(html);\r\n    }\r\n\r\n    static getVariableFromText(text, name, type) {\r\n        let regex;\r\n        if (type === \"object\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(\\\\{.+?\\\\});`);\r\n        } else if (type === \"array\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(\\\\[.+?\\\\]);`);\r\n        } else if (type === \"int\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(.+?);`);\r\n        } else if (type === \"string\") {\r\n            regex = new RegExp(`${name}\\\\s*=\\\\s*(\\\\\".+?\\\\\");`);\r\n        } else {\r\n            return null;\r\n        }\r\n\r\n        const m = text.match(regex);\r\n        if (m) {\r\n            if (type === \"int\") {\r\n                return parseInt(m[1]);\r\n            }\r\n            return JSON.parse(m[1]);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    static getVariableFromDom(name, type, dom = document) {\r\n        for (const node of dom.querySelectorAll(\"script\")) {\r\n            const value = HTMLParser.getVariableFromText(node.textContent, name, type);\r\n\r\n            if (value !== null) {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport {HTMLParser};\r\n","import {IndexedDB} from \"./IndexedDB\";\r\n\r\nclass Api {\r\n\r\n    /*\r\n     * FF doesn't support static members\r\n     * static origin; // this *must* be overridden\r\n     * static params = {};\r\n     * withResponse? use a boolean to include Response object in result?\r\n     */\r\n    static _fetchWithDefaults(endpoint, query = {}, params = {}) {\r\n        const url = new URL(endpoint, this.origin);\r\n        const _params = {...this.params, ...params};\r\n        if (_params && _params.method === \"POST\" && !_params.body) {\r\n            const formData = new FormData();\r\n            for (const [k, v] of Object.entries(query)) {\r\n                formData.append(k, v);\r\n            }\r\n            _params.body = formData;\r\n        } else {\r\n            for (const [k, v] of Object.entries(query)) {\r\n                url.searchParams.append(k, v);\r\n            }\r\n        }\r\n        return fetch(url, _params);\r\n    }\r\n\r\n    static async getEndpoint(endpoint, query, responseHandler, params = {}) {\r\n        let _endpoint = endpoint;\r\n        if (!endpoint.endsWith(\"/\")) { _endpoint += \"/\"; }\r\n\r\n        const response = await this._fetchWithDefaults(_endpoint, query, Object.assign(params, {\"method\": \"GET\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.json();\r\n    }\r\n\r\n    static async getPage(endpoint, query, responseHandler, params = {}) {\r\n        const response = await this._fetchWithDefaults(endpoint, query, Object.assign(params, {\"method\": \"GET\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.text();\r\n    }\r\n\r\n    static async postEndpoint(endpoint, query, responseHandler, params = {}) {\r\n        let _endpoint = endpoint;\r\n        if (!endpoint.endsWith(\"/\")) { _endpoint += \"/\"; }\r\n\r\n        const response = await this._fetchWithDefaults(_endpoint, query, Object.assign(params, {\"method\": \"POST\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.json();\r\n    }\r\n\r\n    static async deleteEndpoint(endpoint, query, responseHandler, params = {}) {\r\n        let _endpoint = endpoint;\r\n        if (!endpoint.endsWith(\"/\")) { _endpoint += \"/\"; }\r\n\r\n        const response = await this._fetchWithDefaults(_endpoint, query, Object.assign(params, {\"method\": \"DELETE\"}));\r\n        if (responseHandler) { responseHandler(response); }\r\n        return response.json();\r\n    }\r\n\r\n    static endpointFactory(endpoint, objPath) {\r\n        return async params => {\r\n            let result = await this.getEndpoint(endpoint, params);\r\n            if (objPath) {\r\n                if (Array.isArray(objPath)) {\r\n                    for (const part of objPath) {\r\n                        result = result[part];\r\n                    }\r\n                } else {\r\n                    result = result[objPath];\r\n                }\r\n            } else {\r\n                result = result.data;\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n\r\n    static endpointFactoryCached(endpoint, storeName, mapFn) {\r\n        return async({params, key} = {}) => {\r\n            let result = await this.getEndpoint(endpoint, params);\r\n\r\n            if (mapFn) {\r\n                result = mapFn(result.data);\r\n            } else {\r\n                result = result.data;\r\n            }\r\n\r\n            return IndexedDB.put(storeName, typeof key === \"undefined\" ? result : new Map([[key, result]]));\r\n        };\r\n    }\r\n}\r\nApi.params = {};\r\n\r\nexport {Api};\r\n","import {TimeUtils} from \"../../Core/Utils/TimeUtils\";\r\nimport {LocalStorage} from \"../../Core/Storage/LocalStorage\";\r\n\r\nclass CacheStorage extends LocalStorage {\r\n\r\n    static isExpired(timestamp, ttl) {\r\n        let _ttl = ttl;\r\n        if (!timestamp) { return true; }\r\n        if (typeof ttl !== \"number\" || _ttl < 0) { _ttl = 0; }\r\n        return timestamp + _ttl <= TimeUtils.now();\r\n    }\r\n\r\n    static get(key) {\r\n\r\n        if (typeof this.ttls[key] === \"undefined\") {\r\n            console.warn(\"No TTL specified for cache storage key\", key);\r\n            return this.defaults[key];\r\n        }\r\n\r\n        const item = super.get(key);\r\n\r\n        if (!item?.timestamp || this.isExpired(item.timestamp, this.ttls[key])) { return this.defaults[key]; }\r\n        return item.data;\r\n    }\r\n\r\n    static set(key, value) {\r\n        return super.set(key, {\"data\": value, \"timestamp\": TimeUtils.now()});\r\n    }\r\n\r\n    // TODO Remove after some versions\r\n    static migrate() {\r\n        localStorage.removeItem(\"cache_currency\");\r\n    }\r\n}\r\n\r\nCacheStorage.ttls = {\r\n    \"currency\": 60 * 60,\r\n};\r\n\r\nCacheStorage.defaults = {\r\n    \"currency\": null,\r\n};\r\n\r\nexport {CacheStorage};\r\n","import {LocalStorage} from \"../../Core/Storage/LocalStorage\";\r\nimport {Errors} from \"../../Core/Errors/Errors\";\r\nimport {GameId} from \"../../Core/GameId\";\r\nimport {HTMLParser} from \"../../Core/Html/HtmlParser\";\r\nimport {Api} from \"./Api\";\r\nimport {CacheStorage} from \"./CacheStorage\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\n\r\nclass SteamCommunityApi extends Api {\r\n\r\n    /*\r\n     * static origin = \"https://steamcommunity.com/\";\r\n     * static params = { 'credentials': 'include', };\r\n     */\r\n\r\n    static cards(appid, border) {\r\n        return SteamCommunityApi.getPage(`/my/gamecards/${appid}`, (border ? {\"border\": 1} : {}));\r\n    }\r\n\r\n    static stats(path, appid) {\r\n        return SteamCommunityApi.getPage(`${path}/stats/${appid}`);\r\n    }\r\n\r\n    static async getInventory(contextId) {\r\n        const login = LocalStorage.get(\"login\");\r\n        if (!login.steamId) {\r\n            console.warn(\"Must be signed in to access Inventory\");\r\n            return null;\r\n        }\r\n\r\n        const params = {\"l\": \"english\", \"count\": 2000};\r\n        let data = null;\r\n        let result, lastAssetid;\r\n\r\n        do {\r\n            const thisParams = Object.assign(params, lastAssetid ? {\"start_assetid\": lastAssetid} : null);\r\n            result = await SteamCommunityApi.getEndpoint(`/inventory/${login.steamId}/753/${contextId}`, thisParams, res => {\r\n                if (res.status === 403) {\r\n                    throw new Errors.LoginError(\"community\");\r\n                }\r\n            });\r\n            if (result && result.success) {\r\n                if (!data) { data = {\"assets\": [], \"descriptions\": []}; }\r\n                if (result.assets) { data.assets = data.assets.concat(result.assets); }\r\n                if (result.descriptions) { data.descriptions = data.descriptions.concat(result.descriptions); }\r\n                lastAssetid = result.last_assetid;\r\n            }\r\n        } while (result.more_items);\r\n\r\n        if (!data) {\r\n            throw new Error(`Could not retrieve Inventory 753/${contextId}`);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /*\r\n     * Inventory functions, must be signed in to function correctly\r\n     */\r\n    static async coupons() { // context#3\r\n        const coupons = new Map();\r\n        const data = await SteamCommunityApi.getInventory(3);\r\n        if (!data) { return null; }\r\n\r\n        for (const description of data.descriptions) {\r\n            if (!description.type || description.type !== \"Coupon\") { continue; }\r\n            if (!description.actions) { continue; }\r\n\r\n            const coupon = {\r\n                \"image_url\": description.icon_url,\r\n                \"title\": description.name,\r\n                \"discount\": description.name.match(/([1-9][0-9])%/)[1],\r\n                \"id\": `${description.classid}_${description.instanceid}`\r\n            };\r\n            description.descriptions.forEach((desc, i) => {\r\n                const value = desc.value;\r\n                if (value.startsWith(\"Can't be applied with other discounts.\")) {\r\n                    Object.assign(coupon, {\r\n                        \"discount_note\": value,\r\n                        \"discount_note_id\": i,\r\n                        \"discount_doesnt_stack\": true,\r\n                    });\r\n                } else if (value.startsWith(\"(Valid\")) {\r\n                    Object.assign(coupon, {\r\n                        \"valid_id\": i,\r\n                        \"valid\": value,\r\n                    });\r\n                }\r\n            });\r\n\r\n            for (const action of description.actions) {\r\n                const match = action.link.match(/[1-9][0-9]*(?:,[1-9][0-9]*)*/);\r\n                if (!match) {\r\n                    console.warn(\"Couldn't find packageid(s) for link %s\", action.link);\r\n                    continue;\r\n                }\r\n\r\n                for (let packageid of match[0].split(\",\")) {\r\n                    packageid = Number(packageid);\r\n                    if (!coupons.has(packageid) || coupons.get(packageid).discount < coupon.discount) {\r\n                        coupons.set(packageid, coupon);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const packages = await IndexedDB.get(\"packages\", Array.from(coupons.keys()));\r\n\r\n        for (const [subid, coupon] of coupons.entries()) {\r\n            const details = packages[subid];\r\n            if (details) {\r\n                coupon.appids = details;\r\n            } else {\r\n                coupon.appids = [];\r\n            }\r\n        }\r\n\r\n        return IndexedDB.put(\"coupons\", coupons);\r\n    }\r\n\r\n    static getCoupon(appid) { return IndexedDB.getFromIndex(\"coupons\", \"appid\", appid); }\r\n    static hasCoupon(appid) { return IndexedDB.indexContainsKey(\"coupons\", \"appid\", appid); }\r\n\r\n    static async giftsAndPasses() { // context#1, gifts and guest passes\r\n        const gifts = [];\r\n        const passes = [];\r\n\r\n        let isPackage;\r\n\r\n        let data = await SteamCommunityApi.getInventory(1);\r\n        if (!data) { return null; }\r\n\r\n        function addGiftsAndPasses(description) {\r\n            const appids = GameId.getAppids(description.value);\r\n\r\n            // Gift package with multiple apps\r\n            isPackage = true;\r\n\r\n            for (const appid of appids) {\r\n                if (!appid) { continue; }\r\n                if (description.type === \"Gift\") {\r\n                    gifts.push(appid);\r\n                } else {\r\n                    passes.push(appid);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const description of data.descriptions) {\r\n            isPackage = false;\r\n            if (description.descriptions) {\r\n                for (const desc of description.descriptions) {\r\n                    if (desc.type !== \"html\") { continue; }\r\n\r\n                    addGiftsAndPasses(desc);\r\n\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Single app\r\n            if (!isPackage && description.actions) {\r\n                const appid = GameId.getAppid(description.actions[0].link);\r\n                if (appid) {\r\n                    if (description.type === \"Gift\") {\r\n                        gifts.push(appid);\r\n                    } else {\r\n                        passes.push(appid);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        data = {\r\n            \"gifts\": gifts,\r\n            \"passes\": passes,\r\n        };\r\n\r\n        return IndexedDB.put(\"giftsAndPasses\", data);\r\n    }\r\n\r\n    static hasGiftsAndPasses(appid) {\r\n        return IndexedDB.getFromIndex(\"giftsAndPasses\", \"appid\", appid, {\"all\": true, \"asKey\": true});\r\n    }\r\n\r\n    static async items() { // context#6, community items\r\n        // only used for market highlighting\r\n        const data = await SteamCommunityApi.getInventory(6);\r\n        if (data) {\r\n            return IndexedDB.put(\"items\", data.descriptions.map(item => item.market_hash_name));\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static hasItem(hashes) { return IndexedDB.contains(\"items\", hashes); }\r\n\r\n    static async fetchWorkshopFileSize({\"key\": id}) {\r\n        const parser = new DOMParser();\r\n        const res = await SteamCommunityApi.getPage(\"/sharedfiles/filedetails/\", {id});\r\n        const doc = parser.parseFromString(res, \"text/html\");\r\n\r\n        const details = doc.querySelector(\".detailsStatRight\");\r\n        if (!details || !details.innerText.includes(\"MB\")) {\r\n            throw new Error(\"Couldn't find details block for workshop file size\");\r\n        }\r\n\r\n        const text = details.innerText.split(\" \")[0].trim();\r\n        const size = parseFloat(text.replace(/,/g, \"\"));\r\n\r\n        return IndexedDB.put(\"workshopFileSizes\", new Map([[Number(id), size * 1000]]));\r\n    }\r\n\r\n    static getWorkshopFileSize(id, preventFetch) {\r\n        return IndexedDB.get(\"workshopFileSizes\", Number(id), {preventFetch});\r\n    }\r\n\r\n    static _getReviewId(node) {\r\n        const input = node.querySelector(\"input\");\r\n\r\n        /*\r\n         * Only exists when the requested profile is yours\r\n         * (these are the input fields where you can change visibility and language of the review)\r\n         */\r\n        if (input) {\r\n            return Number(input.id.replace(\"ReviewVisibility\", \"\"));\r\n        }\r\n\r\n        // Otherwise you have buttons to vote for the review (Was it helpful or not, was it funny?)\r\n        return Number(node.querySelector(\".control_block > a\").id.replace(\"RecommendationVoteUpBtn\", \"\"));\r\n    }\r\n\r\n    static async fetchReviews({\"key\": steamId, \"params\": {reviewCount}}) {\r\n        const parser = new DOMParser();\r\n        const pageCount = 10;\r\n        const reviews = [];\r\n\r\n        for (let p = 1; p <= Math.ceil(reviewCount / pageCount); p++) {\r\n            const doc = parser.parseFromString(await SteamCommunityApi.getPage(`${steamId}/recommended`, {p}), \"text/html\");\r\n\r\n            for (const node of doc.querySelectorAll(\".review_box\")) {\r\n                const headerText = node.querySelector(\".header\").innerHTML.split(\"<br>\");\r\n                const playtimeText = node.querySelector(\".hours\").textContent.split(\"(\")[0].match(/(\\d+,)?\\d+\\.\\d+/);\r\n                const visibilityNode = node.querySelector(\".dselect_container:nth-child(2) .trigger\");\r\n\r\n                const id = SteamCommunityApi._getReviewId(node);\r\n                const rating = node.querySelector(\"[src*=thumbsUp]\") ? 1 : 0;\r\n                const helpful = headerText[0] && headerText[0].match(/\\d+/g) ? parseInt(headerText[0].match(/\\d+/g).join(\"\")) : 0;\r\n                const funny = headerText[1] && headerText[1].match(/\\d+/g) ? parseInt(headerText[1].match(/\\d+/g).join(\"\")) : 0;\r\n                const length = node.querySelector(\".content\").textContent.trim().length;\r\n                const visibility = visibilityNode ? visibilityNode.textContent : \"Public\";\r\n                const playtime = playtimeText ? parseFloat(playtimeText[0].split(\",\").join(\"\")) : 0.0;\r\n\r\n                reviews.push({\r\n                    rating,\r\n                    helpful,\r\n                    funny,\r\n                    length,\r\n                    visibility,\r\n                    playtime,\r\n                    \"node\": DOMPurify.sanitize(node.outerHTML),\r\n                    id\r\n                });\r\n            }\r\n        }\r\n\r\n        return IndexedDB.put(\"reviews\", {[steamId]: reviews});\r\n    }\r\n\r\n    static async updateReviewNode(steamId, html, reviewCount) {\r\n        const parser = new DOMParser();\r\n        const doc = parser.parseFromString(html, \"text/html\");\r\n        const node = doc.querySelector(\".review_box\");\r\n        const id = SteamCommunityApi._getReviewId(node);\r\n\r\n        if (!await IndexedDB.contains(\"reviews\", steamId, {\"preventFetch\": true})) { return null; }\r\n\r\n        const reviews = await IndexedDB.get(\"reviews\", steamId, {\"params\": reviewCount});\r\n\r\n        for (const review of reviews) {\r\n            if (review.id === id) {\r\n                review.node = DOMPurify.sanitize(node.outerHTML);\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Todo updates expiry even though there is no new fetched data\r\n        return IndexedDB.put(\"reviews\", {[steamId]: reviews});\r\n    }\r\n\r\n    static getReviews(steamId, reviewCount) {\r\n        return IndexedDB.get(\"reviews\", steamId, {\"params\": {reviewCount}});\r\n    }\r\n\r\n    /*\r\n     * Invoked when the content script thinks the user is logged in\r\n     * If we don't know the user's steamId, fetch their community profile\r\n     */\r\n    static async login(profilePath) {\r\n        const self = SteamCommunityApi;\r\n\r\n        if (!profilePath) {\r\n            self.logout();\r\n            throw new Error(\"Login endpoint needs a valid profile path\");\r\n        }\r\n        if (!profilePath.startsWith(\"/id/\") && !profilePath.startsWith(\"/profiles/\")) {\r\n            self.logout();\r\n            throw new Error(`Could not interpret ${profilePath} as a valid profile path`);\r\n        }\r\n\r\n        const login = LocalStorage.get(\"login\");\r\n        if (login.profilePath === profilePath) { return login; }\r\n\r\n        const html = await self.getPage(profilePath);\r\n        const profileData = HTMLParser.getVariableFromText(html, \"g_rgProfileData\", \"object\");\r\n        const steamId = profileData.steamid;\r\n\r\n        if (!steamId) { // this should never happen\r\n            throw new Error(\"Failed to retrieve steamID from profile\");\r\n        }\r\n\r\n        self.logout(true);\r\n\r\n        const value = {steamId, profilePath};\r\n        LocalStorage.set(\"login\", value);\r\n\r\n        return value;\r\n    }\r\n\r\n    static logout(newLogout = LocalStorage.has(\"login\")) {\r\n        if (newLogout) {\r\n            LocalStorage.remove(\"login\");\r\n            LocalStorage.remove(\"storeCountry\");\r\n            CacheStorage.remove(\"currency\");\r\n        }\r\n    }\r\n\r\n    // TODO This and (at least) the login calls don't seem appropriate in this class\r\n    static storeCountry(newCountry) {\r\n        if (newCountry) {\r\n            LocalStorage.set(\"storeCountry\", newCountry);\r\n            return null;\r\n        } else {\r\n            return LocalStorage.get(\"storeCountry\");\r\n        }\r\n    }\r\n\r\n    static getProfile(steamId) {\r\n        return IndexedDB.get(\"profiles\", steamId, {\"params\": {\"profile\": steamId}});\r\n    }\r\n\r\n    static clearOwn(steamId) {\r\n        return IndexedDB.delete(\"profiles\", steamId);\r\n    }\r\n\r\n    static async getPage(endpoint, query) {\r\n        const response = await this._fetchWithDefaults(endpoint, query, {\"method\": \"GET\"});\r\n        if (new URL(response.url).pathname === \"/login/home/\") {\r\n            throw new Errors.LoginError(\"community\");\r\n        }\r\n        return response.text();\r\n    }\r\n}\r\nSteamCommunityApi.origin = \"https://steamcommunity.com/\";\r\nSteamCommunityApi.params = {\"credentials\": \"include\"};\r\n\r\nexport {SteamCommunityApi};\r\n","import {HTMLParser} from \"../../Core/Html/HtmlParser\";\r\nimport {Errors} from \"../../Core/Errors/Errors\";\r\nimport {Api} from \"./Api\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\nimport {CacheStorage} from \"./CacheStorage\";\r\n\r\nclass SteamStoreApi extends Api {\r\n\r\n    /*\r\n     * static origin = \"https://store.steampowered.com/\";\r\n     * static params = { 'credentials': 'include', };\r\n     * static _progressingRequests = new Map();\r\n     */\r\n\r\n    static async fetchPackage({\"key\": subid}) {\r\n        const data = await SteamStoreApi.getEndpoint(\"/api/packagedetails/\", {\"packageids\": subid});\r\n        const appids = new Map();\r\n\r\n        for (const [subid, details] of Object.entries(data)) {\r\n            if (details && details.success) {\r\n\r\n                // .apps is an array of { 'id': ##, 'name': \"\", }\r\n                appids.set(Number(subid), details.data.apps.map(obj => obj.id));\r\n            } else {\r\n                appids.set(Number(subid), null);\r\n            }\r\n        }\r\n        return IndexedDB.put(\"packages\", appids);\r\n    }\r\n\r\n    static async wishlistAdd(appid) {\r\n        let res;\r\n        const sessionid = await SteamStoreApi.sessionId();\r\n\r\n        if (sessionid) {\r\n            res = await SteamStoreApi.postEndpoint(\"/api/addtowishlist\", {sessionid, appid});\r\n        }\r\n\r\n        if (!res || !res.success) {\r\n            throw new Error(`Failed to add app ${appid} to wishlist`);\r\n        }\r\n\r\n        return SteamStoreApi.clearDynamicStore();\r\n    }\r\n\r\n    static async wishlistRemove(appid, sessionid) {\r\n        let res;\r\n        let _sessionid = sessionid;\r\n\r\n        if (!_sessionid) {\r\n            _sessionid = await SteamStoreApi.sessionId();\r\n        }\r\n        if (_sessionid) {\r\n            res = await SteamStoreApi.postEndpoint(\"/api/removefromwishlist\", {\"sessionid\": _sessionid, appid});\r\n        }\r\n\r\n        if (!res || !res.success) {\r\n            throw new Error(`Failed to remove app ${appid} from wishlist`);\r\n        }\r\n\r\n        return SteamStoreApi.clearDynamicStore();\r\n    }\r\n\r\n    static async currencyFromWallet() {\r\n        const html = await SteamStoreApi.getPage(\"/steamaccount/addfunds\");\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n\r\n        return dummyPage.querySelector(\"input[name=currency]\").value;\r\n    }\r\n\r\n    static async currencyFromApp() {\r\n        const html = await SteamStoreApi.getPage(\"/app/220\");\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n\r\n        const currency = dummyPage.querySelector(\"meta[itemprop=priceCurrency][content]\");\r\n        if (!currency || !currency.getAttribute(\"content\")) {\r\n            throw new Error(\"Store currency could not be determined from app 220\");\r\n        }\r\n\r\n        return currency.getAttribute(\"content\");\r\n    }\r\n\r\n    static async currency() {\r\n        let currency = CacheStorage.get(\"currency\");\r\n        if (currency) { return currency; }\r\n\r\n        currency = await SteamStoreApi.currencyFromWallet();\r\n        if (!currency) { currency = await SteamStoreApi.currencyFromApp(); }\r\n        if (!currency) { throw new Error(\"Could not retrieve store currency\"); }\r\n\r\n        CacheStorage.set(\"currency\", currency);\r\n        return currency;\r\n    }\r\n\r\n    /*\r\n     * Invoked if we were previously logged out and are now logged in\r\n     */\r\n    static async country() {\r\n        const self = SteamStoreApi;\r\n        const html = await self.getPage(\"/account/change_country/\", {}, res => {\r\n            if (new URL(res.url).pathname === \"/login/\") {\r\n                throw new Errors.LoginError(\"store\");\r\n            }\r\n        });\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n\r\n        const node = dummyPage.querySelector(\"#dselect_user_country\");\r\n        return node && node.value;\r\n    }\r\n\r\n    static async sessionId() {\r\n        const self = SteamStoreApi;\r\n\r\n        // TODO what's the minimal page we can load here to get sessionId?\r\n        const html = await self.getPage(\"/about/\");\r\n        return HTMLParser.getVariableFromText(html, \"g_sessionID\", \"string\");\r\n    }\r\n\r\n    static async wishlists(path) {\r\n        const html = await SteamStoreApi.getPage(`/wishlist${path}`);\r\n        const data = HTMLParser.getVariableFromText(html, \"g_rgWishlistData\", \"array\");\r\n        return data ? data.length : \"\";\r\n    }\r\n\r\n    static async purchaseDate({\"params\": lang}) {\r\n        const replaceRegex = [\r\n            /- Complete Pack/ig,\r\n            /Standard Edition/ig,\r\n            /Steam Store and Retail Key/ig,\r\n            /- Hardware Survey/ig,\r\n            /ComputerGamesRO -/ig,\r\n            /Founder Edition/ig,\r\n            /Retail( Key)?/ig,\r\n            /Complete$/ig,\r\n            /Launch$/ig,\r\n            /Free$/ig,\r\n            /(RoW)/ig,\r\n            /ROW/ig,\r\n            /:/ig,\r\n        ];\r\n        const purchaseDates = new Map();\r\n\r\n        const html = await SteamStoreApi.getPage(\"/account/licenses/\", {\"l\": lang});\r\n        const dummyPage = HTMLParser.htmlToDOM(html);\r\n        const nodes = dummyPage.querySelectorAll(\"#main_content td.license_date_col\");\r\n        for (const node of nodes) {\r\n            const name = node.nextElementSibling;\r\n            const removeNode = name.querySelector(\"div\");\r\n            if (removeNode) { removeNode.remove(); }\r\n\r\n            let appName = HTMLParser.clearSpecialSymbols(name.textContent.trim());\r\n            for (const regex of replaceRegex) {\r\n                appName = appName.replace(regex, \"\");\r\n            }\r\n            appName = appName.trim();\r\n            purchaseDates.set(appName, node.textContent);\r\n        }\r\n\r\n        return IndexedDB.put(\"purchases\", purchaseDates);\r\n    }\r\n\r\n    static purchases(appName, lang) { return IndexedDB.get(\"purchases\", appName, {\"params\": lang}); }\r\n    static clearPurchases() { return IndexedDB.clear(\"purchases\"); }\r\n\r\n    static async dynamicStore() {\r\n        const store = await SteamStoreApi.getEndpoint(\"dynamicstore/userdata\", {}, null, {\"cache\": \"no-cache\"});\r\n        const {rgOwnedApps, rgOwnedPackages, rgIgnoredApps, rgWishlist} = store;\r\n\r\n        const dynamicStore = {\r\n            \"ignored\": Object.keys(rgIgnoredApps).map(key => Number(key)),\r\n            \"ownedApps\": rgOwnedApps,\r\n            \"ownedPackages\": rgOwnedPackages,\r\n            \"wishlisted\": rgWishlist,\r\n        };\r\n\r\n        /*\r\n         * dynamicstore keys are:\r\n         * \"rgWishlist\", \"rgOwnedPackages\", \"rgOwnedApps\", \"rgPackagesInCart\", \"rgAppsInCart\"\r\n         * \"rgRecommendedTags\", \"rgIgnoredApps\", \"rgIgnoredPackages\", \"rgCurators\", \"rgCurations\"\r\n         * \"rgCreatorsFollowed\", \"rgCreatorsIgnored\", \"preferences\", \"rgExcludedTags\",\r\n         * \"rgExcludedContentDescriptorIDs\", \"rgAutoGrantApps\"\r\n         */\r\n\r\n        return IndexedDB.put(\"dynamicStore\", dynamicStore);\r\n    }\r\n\r\n    static dsStatus(ids) {\r\n        return IndexedDB.getFromIndex(\"dynamicStore\", \"appid\", ids, {\"all\": true, \"asKey\": true});\r\n    }\r\n\r\n    static async dynamicStoreRandomApp() {\r\n        const store = await IndexedDB.getAll(\"dynamicStore\");\r\n        if (!store || !store.ownedApps) { return null; }\r\n        return store.ownedApps[Math.floor(Math.random() * store.ownedApps.length)];\r\n    }\r\n\r\n    static async clearDynamicStore() {\r\n        await IndexedDB.clear(\"dynamicStore\");\r\n    }\r\n\r\n    static appDetails(appid, filter) {\r\n        const params = {\"appids\": appid};\r\n        if (filter) { params.filters = filter; }\r\n\r\n        return SteamStoreApi.endpointFactory(\"api/appdetails/\", appid)(params);\r\n    }\r\n\r\n    static appUserDetails(appid) { return SteamStoreApi.endpointFactory(\"api/appuserdetails/\", appid)({\"appids\": appid}); }\r\n}\r\nSteamStoreApi.origin = \"https://store.steampowered.com/\";\r\nSteamStoreApi.params = {\"credentials\": \"include\"};\r\nSteamStoreApi._progressingRequests = new Map();\r\n\r\nexport {SteamStoreApi};\r\n","import {ExtensionResources} from \"../../Core/ExtensionResources\";\r\n\r\nclass StaticResources {\r\n\r\n    static async currencies() {\r\n        const self = StaticResources;\r\n        if (!self._supportedCurrencies || self._supportedCurrencies.length < 1) {\r\n\r\n            /**\r\n             * https://partner.steamgames.com/doc/store/pricing/currencies\r\n             */\r\n            self._supportedCurrencies = await ExtensionResources.getJSON(\"json/currency.json\");\r\n        }\r\n        return self._supportedCurrencies;\r\n    }\r\n}\r\nStaticResources._supportedCurrencies = null;\r\n\r\n\r\nexport {StaticResources};\r\n","// This is the basic configuration for the Augmented Steam extension\r\n\r\nexport default {\r\n    \"ApiServerHost\": \"https://esapi.isthereanydeal.com\",\r\n    \"PublicHost\": \"https://augmentedsteam.com\",\r\n    \"ITADApiServerHost\": \"https://api.isthereanydeal.com\",\r\n    \"ITADClientId\": \"5fe78af07889f43a\"\r\n};\r\n","import {LocalStorage} from \"../../Core/Storage/LocalStorage\";\r\nimport {TimeUtils} from \"../../Core/Utils/TimeUtils\";\r\nimport {SyncedStorage} from \"../../Core/Storage/SyncedStorage\";\r\nimport {Api} from \"./Api\";\r\nimport Config from \"../../config\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\n\r\nclass ITADApi extends Api {\r\n\r\n    static async authorize() {\r\n        const rnd = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        const redirectURI = \"https://isthereanydeal.com/connectaugmentedsteam\";\r\n\r\n        const authUrl = new URL(`${Config.ITADApiServerHost}/oauth/authorize/`);\r\n        authUrl.searchParams.set(\"client_id\", Config.ITADClientId);\r\n        authUrl.searchParams.set(\"response_type\", \"token\");\r\n        authUrl.searchParams.set(\"state\", rnd);\r\n        authUrl.searchParams.set(\"scope\", ITADApi.requiredScopes.join(\" \"));\r\n        authUrl.searchParams.set(\"redirect_uri\", redirectURI);\r\n\r\n        const tab = await browser.tabs.create({\"url\": authUrl.toString()});\r\n\r\n        const url = await new Promise((resolve, reject) => {\r\n            function webRequestListener({url}) {\r\n                resolve(url);\r\n\r\n                browser.webRequest.onBeforeRequest.removeListener(webRequestListener);\r\n                // eslint-disable-next-line no-use-before-define -- Circular dependency\r\n                browser.tabs.onRemoved.removeListener(tabsListener);\r\n\r\n                browser.tabs.remove(tab.id);\r\n                return {\"cancel\": true};\r\n            }\r\n\r\n            function tabsListener(tabId) {\r\n                if (tabId === tab.id) {\r\n                    reject(new Error(\"Authorization tab closed\"));\r\n\r\n                    browser.webRequest.onBeforeRequest.removeListener(webRequestListener);\r\n                    browser.tabs.onRemoved.removeListener(tabsListener);\r\n                }\r\n            }\r\n\r\n            browser.webRequest.onBeforeRequest.addListener(\r\n                webRequestListener,\r\n                {\r\n                    \"urls\": [\r\n                        redirectURI, // For Chrome, seems to not support match patterns (a problem with the Polyfill?)\r\n                        `${redirectURI}#*` // For Firefox\r\n                    ],\r\n                    \"tabId\": tab.id\r\n                },\r\n                [\"blocking\"]\r\n            );\r\n            browser.tabs.onRemoved.addListener(tabsListener);\r\n        });\r\n\r\n        const hashFragment = new URL(url).hash;\r\n        const params = new URLSearchParams(hashFragment.substr(1));\r\n\r\n        if (parseInt(params.get(\"state\")) !== rnd) {\r\n            throw new Error(\"Failed to verify state parameter from URL fragment\");\r\n        }\r\n\r\n        const accessToken = params.get(\"access_token\");\r\n        const expiresIn = params.get(\"expires_in\");\r\n\r\n        if (!accessToken || !expiresIn) {\r\n            throw new Error(`Couldn't retrieve information from URL fragment \"${hashFragment}\"`);\r\n        }\r\n\r\n        LocalStorage.set(\"access_token\", {\r\n            \"token\": accessToken,\r\n            \"expiry\": TimeUtils.now() + parseInt(expiresIn)\r\n        });\r\n    }\r\n\r\n    static disconnect() {\r\n        LocalStorage.remove(\"access_token\");\r\n        LocalStorage.remove(\"lastItadImport\");\r\n        return IndexedDB.clear([\"collection\", \"waitlist\", \"itadImport\"]);\r\n    }\r\n\r\n    static isConnected() {\r\n        const lsEntry = LocalStorage.get(\"access_token\");\r\n        if (!lsEntry) { return false; }\r\n\r\n        if (lsEntry.expiry <= TimeUtils.now()) {\r\n            LocalStorage.remove(\"access_token\");\r\n            return false;\r\n        }\r\n        ITADApi.accessToken = lsEntry.token;\r\n\r\n        return true;\r\n    }\r\n\r\n    static endpointFactoryCached(endpoint, storeName, resultFn) {\r\n        return ({params = {}, key} = {}) => {\r\n            if (ITADApi.isConnected()) {\r\n                return super.endpointFactoryCached(endpoint, storeName, resultFn)(\r\n                    {\"params\": Object.assign(params, {\"access_token\": ITADApi.accessToken}), key}\r\n                );\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n\r\n    static async addToWaitlist(appids) {\r\n        if (!appids || (Array.isArray(appids) && !appids.length)) {\r\n            console.warn(\"Can't add nothing to ITAD waitlist\");\r\n            return null;\r\n        }\r\n\r\n        const waitlistJSON = {\r\n            \"version\": \"02\",\r\n            \"data\": [],\r\n        };\r\n\r\n        const storeids = {};\r\n        if (Array.isArray(appids)) {\r\n            appids.forEach(appid => {\r\n                const id = `app/${appid}`;\r\n                waitlistJSON.data.push({\r\n                    \"gameid\": [\"steam\", id],\r\n                });\r\n                storeids[id] = null;\r\n            });\r\n        } else {\r\n            const id = `app/${appids}`;\r\n            waitlistJSON.data[0] = {\r\n                \"gameid\": [\"steam\", id],\r\n            };\r\n            storeids[id] = null;\r\n        }\r\n\r\n        await ITADApi.postEndpoint(\r\n            \"v01/waitlist/import/\",\r\n            {\"access_token\": ITADApi.accessToken},\r\n            null,\r\n            {\"body\": JSON.stringify(waitlistJSON)}\r\n        );\r\n\r\n        return IndexedDB.put(\"waitlist\", storeids);\r\n    }\r\n\r\n    static async removeFromWaitlist(appids) {\r\n        if (!appids || (Array.isArray(appids) && !appids.length)) {\r\n            throw new Error(\"Can't remove nothing from ITAD Waitlist!\");\r\n        }\r\n\r\n        const _appids = Array.isArray(appids) ? appids : [appids];\r\n        const storeids = _appids.map(appid => `app/${appid}`);\r\n\r\n        await ITADApi.deleteEndpoint(\r\n            \"v02/user/wait/remove/\",\r\n            {\"access_token\": ITADApi.accessToken, \"shop\": \"steam\", \"ids\": storeids.join()}\r\n        );\r\n\r\n        return IndexedDB.delete(\"waitlist\", storeids);\r\n    }\r\n\r\n    static addToCollection(appids, subids) {\r\n        if ((!appids || (Array.isArray(appids) && !appids.length)) && (!subids || (Array.isArray(subids) && !subids.length))) {\r\n            console.warn(\"Can't add nothing to ITAD collection\");\r\n            return null;\r\n        }\r\n\r\n        const collectionJSON = {\r\n            \"version\": \"02\",\r\n            \"data\": [],\r\n        };\r\n\r\n        let _appids;\r\n        if (Array.isArray(appids)) {\r\n            _appids = appids;\r\n        } else if (appids) {\r\n            _appids = [appids];\r\n        } else {\r\n            _appids = [];\r\n        }\r\n\r\n        let _subids;\r\n        if (Array.isArray(subids)) {\r\n            _subids = subids;\r\n        } else if (subids) {\r\n            _subids = [subids];\r\n        } else {\r\n            _subids = [];\r\n        }\r\n\r\n        const storeids = _appids.map(appid => `app/${appid}`).concat(_subids.map(subid => `sub/${subid}`));\r\n        for (const storeid of storeids) {\r\n            collectionJSON.data.push({\r\n                \"gameid\": [\"steam\", storeid],\r\n                \"copies\": [{\r\n                    \"type\": \"steam\",\r\n                    \"status\": \"redeemed\",\r\n                    \"owned\": 1,\r\n                }],\r\n            });\r\n        }\r\n\r\n        return ITADApi.postEndpoint(\r\n            \"v01/collection/import/\",\r\n            {\"access_token\": ITADApi.accessToken},\r\n            null,\r\n            {\"body\": JSON.stringify(collectionJSON)}\r\n        );\r\n    }\r\n\r\n    static async import(force) {\r\n\r\n        if (force) {\r\n            await IndexedDB.clear(\"dynamicStore\");\r\n        } else {\r\n            const lastImport = LocalStorage.get(\"lastItadImport\");\r\n\r\n            if (lastImport && lastImport.to && !IndexedDB.isExpired(lastImport.to + (12 * 60 * 60))) { return; }\r\n        }\r\n\r\n        const dsKeys = [];\r\n        const itadImportKeys = [];\r\n        if (SyncedStorage.get(\"itad_import_library\")) {\r\n            dsKeys.push(\"ownedApps\", \"ownedPackages\");\r\n            itadImportKeys.push(\"lastOwnedApps\", \"lastOwnedPackages\");\r\n        }\r\n\r\n        if (SyncedStorage.get(\"itad_import_wishlist\")) {\r\n            dsKeys.push(\"wishlisted\");\r\n            itadImportKeys.push(\"lastWishlisted\");\r\n        }\r\n\r\n        const result = await Promise.all([\r\n            IndexedDB.get(\"dynamicStore\", dsKeys),\r\n            IndexedDB.get(\"itadImport\", itadImportKeys),\r\n        ]);\r\n\r\n        function removeDuplicates(from, other) {\r\n            if (!from) { return []; }\r\n            if (!other) { return from; }\r\n            return from.filter(el => !other.includes(el));\r\n        }\r\n\r\n        const promises = [];\r\n\r\n        if (SyncedStorage.get(\"itad_import_library\")) {\r\n            const [{ownedApps, ownedPackages}, {lastOwnedApps, lastOwnedPackages}] = result;\r\n            const newOwnedApps = removeDuplicates(ownedApps, lastOwnedApps);\r\n            const newOwnedPackages = removeDuplicates(ownedPackages, lastOwnedPackages);\r\n            if (newOwnedApps.length || newOwnedPackages.length) {\r\n                promises.push(ITADApi.addToCollection(newOwnedApps, newOwnedPackages)\r\n                    .then(() => IndexedDB.put(\"itadImport\", {\r\n                        \"lastOwnedApps\": ownedApps,\r\n                        \"lastOwnedPackages\": ownedPackages,\r\n                    })));\r\n            }\r\n        }\r\n\r\n        if (SyncedStorage.get(\"itad_import_wishlist\")) {\r\n            const [{wishlisted}, {lastWishlisted}] = result;\r\n            const newWishlisted = removeDuplicates(wishlisted, lastWishlisted);\r\n            if (newWishlisted.length) {\r\n                promises.push(ITADApi.addToWaitlist(newWishlisted)\r\n                    .then(() => IndexedDB.put(\"itadImport\", {\"lastWishlisted\": wishlisted})));\r\n            }\r\n        }\r\n\r\n        await Promise.all(promises);\r\n\r\n        const lastImport = LocalStorage.get(\"lastItadImport\");\r\n        lastImport.to = TimeUtils.now();\r\n        LocalStorage.set(\"lastItadImport\", lastImport);\r\n    }\r\n\r\n    static async sync() {\r\n        await Promise.all([\r\n            ITADApi.import(true),\r\n            IndexedDB.clear(\"waitlist\").then(\r\n                () => IndexedDB.objStoreFetchFns.get(\"waitlist\")(\r\n                    {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid\"}}\r\n                )\r\n            ),\r\n            IndexedDB.clear(\"collection\").then(\r\n                () => IndexedDB.objStoreFetchFns.get(\"collection\")(\r\n                    {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid,copy_type\"}}\r\n                )\r\n            ),\r\n        ]);\r\n    }\r\n\r\n    static lastImport() { return LocalStorage.get(\"lastItadImport\"); }\r\n\r\n    static mapCollection(result) {\r\n        if (!result) { return null; }\r\n        const {games, typemap} = result;\r\n\r\n        const collection = {};\r\n        games.forEach(({gameid, types}) => {\r\n            const _types = types.map(type => typemap[type]);\r\n\r\n            collection[gameid] = _types;\r\n        });\r\n\r\n        const lastImport = LocalStorage.get(\"lastItadImport\");\r\n        lastImport.from = TimeUtils.now();\r\n        LocalStorage.set(\"lastItadImport\", lastImport);\r\n\r\n        return collection;\r\n    }\r\n\r\n    static mapWaitlist(result) {\r\n        if (!result) { return null; }\r\n\r\n        const waitlist = [];\r\n        for (const {gameid} of Object.values(result)) {\r\n            waitlist.push(gameid);\r\n        }\r\n\r\n        const lastImport = LocalStorage.get(\"lastItadImport\");\r\n        lastImport.from = TimeUtils.now();\r\n        LocalStorage.set(\"lastItadImport\", lastImport);\r\n\r\n        return waitlist;\r\n    }\r\n\r\n    static inWaitlist(storeIds) {\r\n        return IndexedDB.contains(\"waitlist\", storeIds, {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid\"}});\r\n    }\r\n\r\n    static inCollection(storeIds) {\r\n        return IndexedDB.contains(\"collection\", storeIds, {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid,copy_type\"}});\r\n    }\r\n\r\n    static getFromCollection(storeId) {\r\n        return IndexedDB.get(\"collection\", storeId, {\"params\": {\"shop\": \"steam\", \"optional\": \"gameid,copy_type\"}});\r\n    }\r\n}\r\nITADApi.accessToken = null;\r\nITADApi.requiredScopes = [\r\n    \"wait_read\",\r\n    \"wait_write\",\r\n    \"coll_read\",\r\n    \"coll_write\",\r\n];\r\n\r\nITADApi.origin = Config.ITADApiServerHost;\r\nITADApi._progressingRequests = new Map();\r\n\r\nexport {ITADApi};\r\n","import {Errors} from \"../../Core/Errors/Errors\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\nimport Config from \"../../config\";\r\nimport {Api} from \"./Api\";\r\n\r\nclass AugmentedSteamApi extends Api {\r\n\r\n    /*\r\n     * static origin = Config.ApiServerHost;\r\n     * static _progressingRequests = new Map();\r\n     */\r\n\r\n    static async getEndpoint(endpoint, query) { // withResponse? boolean that includes Response object in result?\r\n        const json = await super.getEndpoint(endpoint, query, response => {\r\n            if (response.status === 500) {\r\n\r\n                /*\r\n                 * Beautify HTTP 500: \"User 'p_enhsteam' has exceeded the 'max_user_connections' resource (current value: XX)\",\r\n                 * which would result in a SyntaxError due to JSON.parse\r\n                 */\r\n                throw new Errors.ServerOutageError(\r\n                    `Augmented Steam servers are currently overloaded, failed to fetch endpoint \"${endpoint}\"`\r\n                );\r\n            }\r\n        });\r\n        if (!json.result || json.result !== \"success\") {\r\n            throw new Error(`Could not retrieve '${endpoint}'`);\r\n        }\r\n        delete json.result;\r\n        return json;\r\n    }\r\n\r\n    static storePageData(appid, metalink, showoc) {\r\n        const params = {\"appid\": appid};\r\n        if (metalink) { params.mcurl = metalink; }\r\n        if (showoc) { params.oc = 1; }\r\n        return IndexedDB.get(\"storePageData\", appid, {params});\r\n    }\r\n\r\n    static expireStorePageData(appid) {\r\n        return IndexedDB.delete(\"storePageData\", `app_${appid}`);\r\n    }\r\n\r\n    static rates(to) {\r\n        return IndexedDB.getAll(\"rates\", {\"params\": {\"to\": to.sort().join(\",\")}});\r\n    }\r\n\r\n    static clearRates() {\r\n        return IndexedDB.clear(\"rates\");\r\n    }\r\n\r\n    static isEA(appids) {\r\n        return IndexedDB.contains(\"earlyAccessAppids\", appids);\r\n    }\r\n\r\n    static steamPeek(appid) {\r\n        return AugmentedSteamApi.endpointFactory(\"v01/similar\")({appid, \"count\": 15});\r\n    }\r\n}\r\nAugmentedSteamApi.origin = Config.ApiServerHost;\r\nAugmentedSteamApi._progressingRequests = new Map();\r\n\r\nexport {AugmentedSteamApi};\r\n","import {SyncedStorage} from \"../../Core/Storage/SyncedStorage\";\r\nimport {IndexedDB} from \"./IndexedDB\";\r\nimport {CacheStorage} from \"./CacheStorage\";\r\n\r\nclass ExtensionData {\r\n    static clearCache() {\r\n        CacheStorage.clear();\r\n        return IndexedDB.clear();\r\n    }\r\n\r\n    /*\r\n     * TEMP(1.4.1)\r\n     * TODO delete after few versions\r\n     */\r\n    static async moveNotesToSyncedStorage() {\r\n        const idbNotes = Object.entries(await IndexedDB.getAll(\"notes\"));\r\n\r\n        const notes = SyncedStorage.get(\"user_notes\");\r\n        for (const [appid, note] of idbNotes) {\r\n            notes[appid] = note;\r\n        }\r\n        SyncedStorage.set(\"user_notes\", notes);\r\n    }\r\n\r\n    static async getNote(appid) {\r\n        const note = await IndexedDB.get(\"notes\", appid);\r\n\r\n        if (typeof note === \"undefined\") { return null; }\r\n        return note;\r\n    }\r\n\r\n    static setNote(appid, note) {\r\n        // Preserve the integer appid\r\n        return IndexedDB.put(\"notes\", new Map([[appid, note]]));\r\n    }\r\n\r\n    static deleteNote(appid) {\r\n        return IndexedDB.delete(\"notes\", appid);\r\n    }\r\n\r\n    static getAllNotes() {\r\n        return IndexedDB.getAll(\"notes\");\r\n    }\r\n\r\n    static async setAllNotes(notes) {\r\n        await ExtensionData.clearNotes();\r\n\r\n        // Preserve the integer appid\r\n        const map = new Map(Object.entries(notes).map(([appid, note]) => [Number(appid), note]));\r\n        return IndexedDB.put(\"notes\", map);\r\n    }\r\n\r\n    static clearNotes() {\r\n        return IndexedDB.clear(\"notes\");\r\n    }\r\n}\r\n\r\nexport {ExtensionData};\r\n","import setup from \"../setup\";\r\nimport {LocalStorage, Permissions, SyncedStorage} from \"../modulesCore\";\r\nimport {ContextMenu} from \"./Modules/ContextMenu\";\r\nimport {IndexedDB} from \"./Modules/IndexedDB\";\r\nimport {SteamCommunityApi} from \"./Modules/SteamCommunityApi\";\r\nimport {SteamStoreApi} from \"./Modules/SteamStoreApi\";\r\nimport {StaticResources} from \"./Modules/StaticResources\";\r\nimport {ITADApi} from \"./Modules/ITADApi\";\r\nimport {AugmentedSteamApi} from \"./Modules/AugmentedSteamApi\";\r\nimport {ExtensionData} from \"./Modules/ExtensionData\";\r\nimport {CacheStorage} from \"./Modules/CacheStorage\";\r\n\r\n// Functions that are called when an object store (or one of its entries) has expired\r\nIndexedDB.objStoreFetchFns = new Map([\r\n    [\"coupons\", SteamCommunityApi.coupons],\r\n    [\"giftsAndPasses\", SteamCommunityApi.giftsAndPasses],\r\n    [\"items\", SteamCommunityApi.items],\r\n    [\"workshopFileSizes\", SteamCommunityApi.fetchWorkshopFileSize],\r\n    [\"reviews\", SteamCommunityApi.fetchReviews],\r\n\r\n    [\"purchases\", SteamStoreApi.purchaseDate],\r\n    [\"dynamicStore\", SteamStoreApi.dynamicStore],\r\n    [\"packages\", SteamStoreApi.fetchPackage],\r\n\r\n    [\"earlyAccessAppids\", AugmentedSteamApi.endpointFactoryCached(\"v01/earlyaccess\", \"earlyAccessAppids\")],\r\n    [\"storePageData\", AugmentedSteamApi.endpointFactoryCached(\"v01/storepagedata\", \"storePageData\")],\r\n    [\"profiles\", AugmentedSteamApi.endpointFactoryCached(\"v01/profile/profile\", \"profiles\")],\r\n    [\"rates\", AugmentedSteamApi.endpointFactoryCached(\"v01/rates\", \"rates\")],\r\n\r\n    [\"collection\", ITADApi.endpointFactoryCached(\"v02/user/coll/all\", \"collection\", ITADApi.mapCollection)],\r\n    [\"waitlist\", ITADApi.endpointFactoryCached(\"v01/user/wait/all\", \"waitlist\", ITADApi.mapWaitlist)],\r\n]);\r\n\r\nconst actionCallbacks = new Map([\r\n    [\"wishlist.add\", SteamStoreApi.wishlistAdd],\r\n    [\"wishlist.remove\", SteamStoreApi.wishlistRemove],\r\n    [\"dynamicstore.clear\", SteamStoreApi.clearDynamicStore],\r\n\r\n    [\"steam.currencies\", StaticResources.currencies],\r\n\r\n    [\"migrate.cachestorage\", CacheStorage.migrate],\r\n    [\"migrate.notesToSyncedStorage\", ExtensionData.moveNotesToSyncedStorage],\r\n\r\n    [\"notes.get\", ExtensionData.getNote],\r\n    [\"notes.set\", ExtensionData.setNote],\r\n    [\"notes.delete\", ExtensionData.deleteNote],\r\n    [\"notes.getall\", ExtensionData.getAllNotes],\r\n    [\"notes.setall\", ExtensionData.setAllNotes],\r\n    [\"notes.clear\", ExtensionData.clearNotes],\r\n    [\"cache.clear\", ExtensionData.clearCache],\r\n\r\n    [\"dlcinfo\", AugmentedSteamApi.endpointFactory(\"v01/dlcinfo\")],\r\n    [\"storepagedata\", AugmentedSteamApi.storePageData],\r\n    [\"storepagedata.expire\", AugmentedSteamApi.expireStorePageData],\r\n    [\"prices\", AugmentedSteamApi.endpointFactory(\"v01/prices\")],\r\n    [\"rates\", AugmentedSteamApi.rates],\r\n    [\"clearrates\", AugmentedSteamApi.clearRates],\r\n    [\"isea\", AugmentedSteamApi.isEA],\r\n    [\"profile.background\", AugmentedSteamApi.endpointFactory(\"v01/profile/background/background\")],\r\n    [\"profile.background.games\", AugmentedSteamApi.endpointFactory(\"v01/profile/background/games\")],\r\n    [\"twitch.stream\", AugmentedSteamApi.endpointFactory(\"v01/twitch/stream\")],\r\n    [\"market.cardprices\", AugmentedSteamApi.endpointFactory(\"v01/market/cardprices\")],\r\n    [\"market.averagecardprices\", AugmentedSteamApi.endpointFactory(\"v01/market/averagecardprices\")],\r\n    [\"steampeek\", AugmentedSteamApi.steamPeek],\r\n\r\n    [\"appdetails\", SteamStoreApi.appDetails],\r\n    [\"appuserdetails\", SteamStoreApi.appUserDetails],\r\n    [\"currency\", SteamStoreApi.currency],\r\n    [\"sessionid\", SteamStoreApi.sessionId],\r\n    [\"wishlists\", SteamStoreApi.wishlists],\r\n    [\"purchases\", SteamStoreApi.purchases],\r\n    [\"clearpurchases\", SteamStoreApi.clearPurchases],\r\n    [\"dynamicstorestatus\", SteamStoreApi.dsStatus],\r\n    [\"dynamicStore.randomApp\", SteamStoreApi.dynamicStoreRandomApp],\r\n\r\n    [\"login\", SteamCommunityApi.login],\r\n    [\"logout\", SteamCommunityApi.logout],\r\n    [\"storecountry\", SteamCommunityApi.storeCountry],\r\n    [\"cards\", SteamCommunityApi.cards],\r\n    [\"stats\", SteamCommunityApi.stats],\r\n    [\"coupon\", SteamCommunityApi.getCoupon],\r\n    [\"hasgiftsandpasses\", SteamCommunityApi.hasGiftsAndPasses],\r\n    [\"hascoupon\", SteamCommunityApi.hasCoupon],\r\n    [\"hasitem\", SteamCommunityApi.hasItem],\r\n    [\"profile\", SteamCommunityApi.getProfile],\r\n    [\"clearownprofile\", SteamCommunityApi.clearOwn],\r\n    [\"workshopfilesize\", SteamCommunityApi.getWorkshopFileSize],\r\n    [\"reviews\", SteamCommunityApi.getReviews],\r\n    [\"updatereviewnode\", SteamCommunityApi.updateReviewNode],\r\n\r\n    [\"itad.authorize\", ITADApi.authorize],\r\n    [\"itad.disconnect\", ITADApi.disconnect],\r\n    [\"itad.isconnected\", ITADApi.isConnected],\r\n    [\"itad.import\", ITADApi.import],\r\n    [\"itad.sync\", ITADApi.sync],\r\n    [\"itad.lastimport\", ITADApi.lastImport],\r\n    [\"itad.inwaitlist\", ITADApi.inWaitlist],\r\n    [\"itad.addtowaitlist\", ITADApi.addToWaitlist],\r\n    [\"itad.removefromwaitlist\", ITADApi.removeFromWaitlist],\r\n    [\"itad.incollection\", ITADApi.inCollection],\r\n    [\"itad.getfromcollection\", ITADApi.getFromCollection],\r\n\r\n    [\"error.test\", () => { return Promise.reject(new Error(\"This is a TEST Error. Please ignore.\")); }],\r\n]);\r\n\r\n/*\r\n * new Map() for Map.prototype.get() in lieu of:\r\n * Object.prototype.hasOwnProperty.call(actionCallbacks, message.action)\r\n */\r\n\r\nbrowser.runtime.onMessage.addListener(async(message, sender) => {\r\n    if (!sender || !sender.tab) { return null; } // not from a tab, ignore\r\n    if (!message || !message.action) { return null; }\r\n\r\n    const callback = actionCallbacks.get(message.action);\r\n    if (!callback) {\r\n\r\n        // requested action not recognized, reply with error immediately\r\n        throw new Error(`Did not recognize \"${message.action}\" as an action.`);\r\n    }\r\n\r\n    message.params = message.params || [];\r\n    let res;\r\n    try {\r\n        await Promise.all([IndexedDB, CacheStorage, LocalStorage, SyncedStorage.then(() => { setup(); })]);\r\n        res = await callback(...message.params);\r\n    } catch (err) {\r\n        console.group(`Callback: \"${message.action}\"`);\r\n        console.error('Failed to execute callback \"%s\" with params %o', message.action, message.params);\r\n        console.error(err);\r\n        console.groupEnd();\r\n\r\n        throw new Error(err.toString());\r\n    }\r\n    return res;\r\n});\r\n\r\nbrowser.runtime.onStartup.addListener(ContextMenu.update);\r\nbrowser.runtime.onInstalled.addListener(ContextMenu.update);\r\n\r\nPermissions.when(\"contextMenus\", () => {\r\n    browser.contextMenus.onClicked.addListener(ContextMenu.onClick);\r\n}, () => {\r\n    browser.contextMenus.onClicked.removeListener(ContextMenu.onClick);\r\n});\r\n"],"names":["Storage","static","key","Object","prototype","hasOwnProperty","call","this","cache","defaults","console","warn","value","_adapter","set","entries","remove","prefix","keys","filter","k","startsWith","force","tmp","persistent","reduce","acc","option","clear","import","area","browser","storage","sync","caches","onChanged","addListener","changes","eventArea","val","assign","get","onDone","onCatch","promise","_initialized","Promise","resolve","init","then","JSON","stringify","runtime","getManifest","version","SyncedStorage","local","QUOTA_BYTES_PER_ITEM","freeze","initialized","LoginError","Error","constructor","type","super","name","ServerOutageError","msg","HTTPError","code","message","FeatureDependencyError","featureName","Errors","CookieStorage","defaultValue","_name","trim","has","ttl","_val","encodeURIComponent","document","cookie","delete","Map","split","map","kv","decodeURIComponent","ContextType","currentContext","extension","getBackgroundPage","bgPage","window","BACKGROUND","OPTIONS","CONTENT_SCRIPT","Environment","Language","_currentSteamLanguage","script","querySelectorAll","language","URL","src","searchParams","isContentScript","languages","array","includes","getCurrentSteamLanguage","ExtensionResources","pathname","getURL","fetch","r","json","text","Localization","getJSON","_promise","currentSteamLanguage","storedSteamLanguage","deepAssign","target","source","sendMessage","requested","params","length","action","getLanguageCode","codes","push","all","lc","loadLocalization","english","str","path","reverse","current","pop","LocalStorage","migrate","migrationDone","location","hostname","async","localStorage","getItem","parse","err","error","removeItem","ctxPermissions","PermissionOptions","Permissions","permissionList","permissions","contains","request","contextMenus","removeAll","permission","onAdded","onRemoved","p","optionToRemove","unusedPermissions","_getUnusedPermissions","used","Set","setup","add","unused","Array","from","values","ContextMenu","info","url","queryLinks","menuItemId","query","selectionText","steamKeys","match","isArray","join","tabs","create","replace","options","chrome","lastError","build","Timer","duration","_id","setTimeout","onSuccess","onFail","clearTimeout","ResettableTimer","reset","running","_running","TimeUtils","Math","trunc","Date","now","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","transformCachableValue","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","args","apply","unwrap","storeNames","tx","sort","done","reject","unlisten","removeEventListener","complete","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","success","result","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","useIndex","isWrite","method","storeName","store","index","shift","oldTraps","IndexedDB","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","db","openDB","createObjectStore","createIndex","deleteIndex","_deleteOldData","expiryStore","cursor","openCursor","IDBKeyRange","upperBound","expired","stores","promises","primaryKey","expiryKey","dataStore","timestampedStores","strKeyPromise","nmbKey","Number","data","multiple","expiry","expiryKeys","cached","cacheObjectStores","timestampedEntry","timestampedEntriesStores","nonAssociativeData","autoIncrement","keyPath","put","_ttl","forEach","expiryTx","_asArray","checkStoreExpiry","checkEntryExpiry","_resultsAsObject","getAllKeys","indexName","asKey","getKey","getAll","openKeyCursor","Boolean","dataPromise","clearPromise","bound","String","fromCharCode","charCodeAt","isExpired","preventFetch","dataTx","fetchUpdatedData","requestKey","_ongoingRequests","req","timestampedStore","objStoreFetchFns","group","groupEnd","finally","i","GameId","id","parseInt","_text","HTMLElement","appid","dataset","dsAppid","parseId","href","m","subid","dsPackageid","bundleid","dsBundleid","storeId","slice","indexOf","HTMLImageElement","hasAttribute","getAttribute","imageUrl","regex","res","exec","HTML","html","template","createElement","innerHTML","DOMPurify","sanitize","content","fragment","firstElementChild","node","_node","querySelector","Element","_getNode","outerHTML","wrapper","startEl","endEl","_startEl","_endEl","parentElement","lastElementChild","wrappedNodes","cur","nextElementSibling","_wrapper","element","replaceWith","append","position","insertAdjacentHTML","adjacent","HTMLParser","string","RegExp","dom","getVariableFromText","textContent","Api","endpoint","origin","_params","body","formData","FormData","v","responseHandler","_endpoint","endsWith","response","_fetchWithDefaults","objPath","getEndpoint","part","mapFn","CacheStorage","timestamp","ttls","item","SteamCommunityApi","border","getPage","contextId","login","steamId","lastAssetid","thisParams","status","assets","concat","descriptions","last_assetid","more_items","coupons","getInventory","description","actions","coupon","icon_url","classid","instanceid","desc","link","packageid","discount","packages","details","appids","getFromIndex","indexContainsKey","gifts","passes","isPackage","addGiftsAndPasses","getAppids","getAppid","market_hash_name","hashes","parser","DOMParser","parseFromString","innerText","size","parseFloat","input","reviewCount","reviews","ceil","doc","headerText","playtimeText","visibilityNode","_getReviewId","rating","helpful","funny","visibility","playtime","review","profilePath","self","logout","steamid","newLogout","newCountry","SteamStoreApi","apps","obj","sessionid","sessionId","postEndpoint","clearDynamicStore","_sessionid","htmlToDOM","currency","currencyFromWallet","currencyFromApp","lang","replaceRegex","purchaseDates","nodes","removeNode","appName","clearSpecialSymbols","rgOwnedApps","rgOwnedPackages","rgIgnoredApps","rgWishlist","dynamicStore","ids","ownedApps","floor","random","filters","endpointFactory","_progressingRequests","StaticResources","_supportedCurrencies","ITADApi","rnd","crypto","getRandomValues","Uint32Array","redirectURI","authUrl","requiredScopes","tab","toString","webRequestListener","webRequest","onBeforeRequest","removeListener","tabsListener","tabId","hashFragment","hash","URLSearchParams","substr","accessToken","expiresIn","lsEntry","token","resultFn","isConnected","endpointFactoryCached","waitlistJSON","storeids","deleteEndpoint","subids","collectionJSON","_appids","_subids","storeid","lastImport","to","dsKeys","itadImportKeys","removeDuplicates","other","el","ownedPackages","lastOwnedApps","lastOwnedPackages","newOwnedApps","newOwnedPackages","addToCollection","wishlisted","lastWishlisted","newWishlisted","addToWaitlist","games","typemap","collection","gameid","types","_types","waitlist","storeIds","AugmentedSteamApi","metalink","showoc","mcurl","oc","ExtensionData","idbNotes","notes","note","clearNotes","giftsAndPasses","items","fetchWorkshopFileSize","fetchReviews","purchaseDate","fetchPackage","mapCollection","mapWaitlist","actionCallbacks","wishlistAdd","wishlistRemove","currencies","moveNotesToSyncedStorage","getNote","setNote","deleteNote","getAllNotes","setAllNotes","clearCache","storePageData","expireStorePageData","rates","clearRates","isEA","steamPeek","appDetails","appUserDetails","wishlists","purchases","clearPurchases","dsStatus","dynamicStoreRandomApp","storeCountry","cards","stats","getCoupon","hasGiftsAndPasses","hasCoupon","hasItem","getProfile","clearOwn","getWorkshopFileSize","getReviews","updateReviewNode","authorize","disconnect","inWaitlist","removeFromWaitlist","inCollection","getFromCollection","onMessage","sender","callback","purifyConfig","ADD_ATTR","addHook","attrName","attrValue","setAttribute","keepAttr","setConfig","onStartup","update","onInstalled","when","onClicked","onClick"],"sourceRoot":""}